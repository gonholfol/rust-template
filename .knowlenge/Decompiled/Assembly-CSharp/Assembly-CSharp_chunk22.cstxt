using Rust.Ai.Gen2;
using UnityEngine;

public abstract class State_PlayAnimationBase : FSMStateBase
{
	[SerializeField]
	public bool FaceTarget;

	protected RootMotionPlayer.PlayServerState animState;

	public override EFSMStateStatus OnStateEnter()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (FaceTarget && base.Senses.FindTargetPosition(out var targetPosition))
		{
			Vector3 val = targetPosition - ((Component)Owner).transform.position;
			val.y = 0f;
			((Component)Owner).transform.rotation = Quaternion.LookRotation(val);
		}
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!animState.isPlaying)
		{
			return EFSMStateStatus.Success;
		}
		return EFSMStateStatus.None;
	}

	public override void OnStateExit()
	{
		base.AnimPlayer.StopServerAndReturnToPool(ref animState);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Animation);
		return result;
	}

	protected virtual AnimationClip GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimationRM : State_PlayAnimationBase
{
	[SerializeField]
	public RootMotionData Animation;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(GetAnimation());
		return result;
	}

	protected virtual RootMotionData GetAnimation()
	{
		return Animation;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayRandomAnimation : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip[] animations;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(animations.GetRandom());
		return result;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class State_PlayAnimLoop : State_PlayAnimationBase
{
	[SerializeField]
	public AnimationClip Start;

	[SerializeField]
	public AnimationClip Loop;

	[SerializeField]
	public AnimationClip Stop;

	[SerializeField]
	public float MinDuration = 7f;

	[SerializeField]
	public float MaxDuration = 14f;

	private float duration;

	public override EFSMStateStatus OnStateEnter()
	{
		EFSMStateStatus result = base.OnStateEnter();
		duration = Random.Range(MinDuration, MaxDuration);
		animState = base.AnimPlayer.PlayServerAndTakeFromPool(Start);
		return result;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (duration > 0f)
		{
			duration -= deltaTime;
			if (duration <= 0f)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Stop);
			}
			else if (!animState.isPlaying)
			{
				base.AnimPlayer.StopServerAndReturnToPool(ref animState, interrupt: false);
				animState = base.AnimPlayer.PlayServerAndTakeFromPool(Loop);
			}
		}
		return base.OnStateUpdate(deltaTime);
	}
}


using System;
using System.Linq;
using Rust.Ai.Gen2;
using UnityEngine;

public abstract class FSMTransitionBase
{
	[SerializeField]
	public bool Inverted;

	[NonSerialized]
	public BaseEntity Owner;

	private SenseComponent _senses;

	private LimitedTurnNavAgent _agent;

	protected SenseComponent Senses => _senses ?? (_senses = ((Component)Owner).GetComponent<SenseComponent>());

	protected LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)Owner).GetComponent<LimitedTurnNavAgent>());

	public virtual void Init(BaseEntity owner)
	{
		Owner = owner;
	}

	public virtual void OnStateEnter()
	{
	}

	public virtual void OnStateExit()
	{
	}

	public virtual void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
	}

	public bool Evaluate()
	{
		if (!Inverted)
		{
			return EvaluateInternal();
		}
		return !EvaluateInternal();
	}

	protected virtual bool EvaluateInternal()
	{
		return false;
	}

	public virtual string GetName()
	{
		return (Inverted ? "!" : "") + GetGenericTypeName(GetType());
	}

	protected static string GetGenericTypeName(Type type)
	{
		if (type.IsGenericType)
		{
			string name = type.Name;
			return (name[..name.IndexOf('`')] + "<" + string.Join(", ", type.GetGenericArguments().Select(GetGenericTypeName)) + ">").Replace("Trans_", "");
		}
		return type.Name.Replace("Trans_", "");
	}

	public virtual FSMTransitionBase Clone()
	{
		return (FSMTransitionBase)MemberwiseClone();
	}

	public static Trans_And operator &(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_And { lhs, rhs };
	}

	public static Trans_Or operator |(FSMTransitionBase lhs, FSMTransitionBase rhs)
	{
		return new Trans_Or { lhs, rhs };
	}

	public static FSMTransitionBase operator ~(FSMTransitionBase instance)
	{
		instance.Inverted = !instance.Inverted;
		return instance;
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
public class Trans_AlwaysValid : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public abstract class Trans_Composite : FSMTransitionBase, IEnumerable<FSMTransitionBase>, IEnumerable
{
	[SerializeField]
	protected List<FSMTransitionBase> transitions = new List<FSMTransitionBase>();

	public IEnumerator<FSMTransitionBase> GetEnumerator()
	{
		return transitions.GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}

	public void Add(FSMTransitionBase transition)
	{
		transitions.Add(transition);
	}

	public Trans_Composite()
	{
	}

	public override void Init(BaseEntity owner)
	{
		base.Init(owner);
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.Init(owner);
		}
	}

	public Trans_Composite(List<FSMTransitionBase> transitions)
	{
		this.transitions = transitions;
	}

	public override void OnStateEnter()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateEnter();
		}
	}

	public override void OnStateExit()
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnStateExit();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		foreach (FSMTransitionBase transition in transitions)
		{
			transition.OnTransitionTaken(from, to);
		}
	}

	protected virtual string GetNameSeparator()
	{
		return " ";
	}

	public override string GetName()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("(");
		for (int i = 0; i < transitions.Count; i++)
		{
			stringBuilder.Append(transitions[i].GetName());
			if (i < transitions.Count - 1)
			{
				stringBuilder.Append(" ");
				stringBuilder.Append(GetNameSeparator());
				stringBuilder.Append(" ");
			}
		}
		stringBuilder.Append(" )");
		return stringBuilder.ToString();
	}

	public override FSMTransitionBase Clone()
	{
		Trans_Composite obj = base.Clone() as Trans_Composite;
		obj.transitions = new List<FSMTransitionBase>();
		return obj;
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_And : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_And", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (!transition.Evaluate())
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "&&";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Or : Trans_Composite
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Or", 0);
		try
		{
			foreach (FSMTransitionBase transition in transitions)
			{
				if (transition.Evaluate())
				{
					return true;
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected override string GetNameSeparator()
	{
		return "||";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

public class Trans_Lambda : FSMTransitionBase
{
	private Func<BaseEntity, bool> EvaluateFunc;

	public Trans_Lambda(Func<BaseEntity, bool> evaluateFunc)
	{
		EvaluateFunc = evaluateFunc;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Lambda", 0);
		try
		{
			if ((Object)(object)Owner == (Object)null)
			{
				return false;
			}
			return EvaluateFunc(Owner);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_RandomChance : FSMTransitionBase
{
	[SerializeField]
	public float Chance = 0.5f;

	private bool Triggered;

	public override void OnStateEnter()
	{
		Triggered = Random.value <= Chance;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_RandomChance", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_Cooldown : FSMTransitionBase
{
	[SerializeField]
	public float cooldown = 20f;

	private double? lastTakenTime;

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		lastTakenTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Cooldown", 0);
		try
		{
			return !lastTakenTime.HasValue || Time.timeAsDouble - lastTakenTime.Value >= (double)cooldown;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {cooldown}s";
	}
}


using System;
using Rust.Ai.Gen2;

public class Trans_Triggerable : FSMTransitionBase
{
	protected bool Triggered { get; private set; }

	public void Trigger()
	{
		Triggered = true;
	}

	public override void OnStateEnter()
	{
		Triggered = false;
	}

	public override void OnStateExit()
	{
		Triggered = false;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_Triggerable", 0);
		try
		{
			return Triggered;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;

public class Trans_Triggerable<T> : Trans_Triggerable
{
	private T Parameter;

	public void Trigger(T parameter)
	{
		Parameter = parameter;
		Trigger();
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		if (base.Triggered && to is IParametrized<T> parametrized)
		{
			parametrized.SetParameter(Parameter);
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTime : FSMTransitionBase
{
	[SerializeField]
	public double Duration = 6.0;

	private double startTime;

	public override void OnStateEnter()
	{
		startTime = Time.timeAsDouble;
	}

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_ElapsedTime", 0);
		try
		{
			return Time.timeAsDouble >= startTime + Duration;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Duration}s";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_ElapsedTimeRandomized : Trans_ElapsedTime
{
	[SerializeField]
	public double MinDuration = 2.0;

	[SerializeField]
	public double MaxDuration = 6.0;

	public override void OnStateEnter()
	{
		Duration = MinDuration + (double)Random.value * (MaxDuration - MinDuration);
		base.OnStateEnter();
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInRange : FSMTransitionBase
{
	[SerializeField]
	public float Range = 4f;

	[SerializeField]
	public float TimeToPredict;

	protected override bool EvaluateInternal()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInRange", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			Vector3 val2 = ((Component)target).transform.position;
			if (TimeToPredict > 0f && target.ToNonNpcPlayer(out var player))
			{
				Vector3 inferedVelocity = player.inferedVelocity;
				inferedVelocity = Vector3.ProjectOnPlane(inferedVelocity, ((Component)Owner).transform.right);
				val2 += inferedVelocity * TimeToPredict;
			}
			return Vector3.Distance(val2, ((Component)Owner).transform.position) <= Range;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}m", base.GetName(), Inverted ? ">=" : "<", Range);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
public class Trans_TargetInFront : FSMTransitionBase
{
	[SerializeField]
	public float Angle = 90f;

	protected override bool EvaluateInternal()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_TargetInFront", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 val2 = targetPosition - ((Component)Owner).transform.position;
			return Vector3.Angle(((Component)Owner).transform.forward, val2) < Angle;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return string.Format("{0} {1}{2}Â°", base.GetName(), Inverted ? ">=" : "<", Angle);
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_TargetIsNearFire : FSMTransitionBase
{
	public bool onlySeeFireWhenClose;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsNearFire", 0);
		try
		{
			return Test(Owner, base.Senses, onlySeeFireWhenClose);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Test(BaseEntity owner, SenseComponent senses, bool onlySeeFireWhenClose = false)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Test", 0);
		try
		{
			if (!senses.FindTarget(out var target))
			{
				return false;
			}
			if (target.ToNonNpcPlayer(out var player) && SingletonComponent<NpcNoiseManager>.Instance.HasPlayerSpokenNear(owner, player))
			{
				return true;
			}
			if (!senses.FindFire(out var fire))
			{
				return false;
			}
			bool flag = Vector3.Distance(((Component)target).transform.position, ((Component)fire).transform.position) < 16f;
			bool flag2 = Vector3.Distance(((Component)owner).transform.position, ((Component)target).transform.position) < 18f;
			if (onlySeeFireWhenClose)
			{
				return flag && flag2;
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_HasTarget : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasTarget", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using Rust.Ai.Gen2;
using UnityEngine;

internal abstract class FSMSlowTransitionBase : FSMTransitionBase
{
	private bool cachedEvalResult;

	private double? lastEvalTime;

	private double cacheLifeTime = 1.0;

	protected sealed override bool EvaluateInternal()
	{
		double timeAsDouble = Time.timeAsDouble;
		if (!lastEvalTime.HasValue || timeAsDouble - lastEvalTime.Value > cacheLifeTime)
		{
			cachedEvalResult = EvaluateAtInterval();
			lastEvalTime = timeAsDouble;
		}
		return cachedEvalResult;
	}

	protected abstract bool EvaluateAtInterval();
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_CanReachTarget_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_CanReachTarget_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			return base.Agent.CanReach(targetPosition);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsTargetOnNavmesh_Slow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsTargetOnNavmesh_Slow", 0);
		try
		{
			if (!base.Senses.FindTargetPosition(out var targetPosition))
			{
				return false;
			}
			Vector3 sample;
			return base.Agent.SamplePosition(targetPosition, out sample, 2f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsHealthBelowPercentage : FSMTransitionBase
{
	[SerializeField]
	public float percentage = 0.25f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsHealthBelowPercentage", 0);
		try
		{
			return Owner is BaseCombatEntity baseCombatEntity && baseCombatEntity.healthFraction < percentage;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{percentage * 100f}%";
	}
}


using System;
using ConVar;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsNavmeshReady : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsNavmeshReady", 0);
		try
		{
			return AI.move && base.Agent.IsNavmeshReady;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_InitialAlliesNotFighting : FSMTransitionBase
{
	[SerializeField]
	public float MinAllyHealthFraction = 0.3f;

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_InitialAlliesNotFighting", 0);
		try
		{
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				base.Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!((Component)item).GetComponent<SenseComponent>().FindTarget(out var _) && (!(item is BaseCombatEntity baseCombatEntity) || !(baseCombatEntity.healthFraction < MinAllyHealthFraction)))
					{
						return true;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_HasBlackboardBool : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			return Blackboard.Has(Key);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return base.GetName() + " " + Key;
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_BlackboardCounterGte : FSMTransitionBase
{
	[SerializeField]
	public string Key;

	[SerializeField]
	public int MinValue;

	private BlackboardComponent _blackboard;

	private BlackboardComponent Blackboard => _blackboard ?? (_blackboard = ((Component)Owner).GetComponent<BlackboardComponent>());

	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_HasBlackboardBool", 0);
		try
		{
			if (!Blackboard.Count(Key, out var count))
			{
				return false;
			}
			return count >= MinValue;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} {Key} >= {MinValue}";
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_NoiseNearby : FSMTransitionBase
{
	[SerializeField]
	public float distance = 7f;

	protected override bool EvaluateInternal()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_NoiseNearby", 0);
		try
		{
			NpcNoiseEvent currentNoise = base.Senses.currentNoise;
			return currentNoise != null && Vector3.Distance(((Component)Owner).transform.position, currentNoise.Position) < distance;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnTransitionTaken(FSMStateBase from, FSMStateBase to)
	{
		base.OnTransitionTaken(from, to);
		if (base.Senses.currentNoise != null)
		{
			if (to is IParametrized<NpcNoiseEvent> parametrized)
			{
				parametrized.SetParameter(base.Senses.currentNoise);
			}
			base.Senses.ConsumeCurrentNoise();
		}
	}

	public override string GetName()
	{
		return $"{base.GetName()} <{distance}m";
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_SeesFood : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_SeesFood", 0);
		try
		{
			BaseEntity food;
			return base.Senses.FindFood(out food);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsTargetInWater : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsTargetInWater", 0);
		try
		{
			if (!base.Senses.FindTarget(out var target))
			{
				return false;
			}
			if (!target.ToNonNpcPlayer(out var _))
			{
				return false;
			}
			if (!base.Senses.GetVisibilityStatus(target, out var status))
			{
				return false;
			}
			return status.isInWaterCached;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_IsSwimming : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_IsSwimming", 0);
		try
		{
			return base.Agent.canSwim && base.Agent.IsSwimming;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
internal class Trans_IsInWaterSlow : FSMSlowTransitionBase
{
	protected override bool EvaluateAtInterval()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Trans_IsInWaterSlow", 0);
		try
		{
			if (base.Agent.canSwim)
			{
				return base.Agent.IsSwimming;
			}
			return WaterLevel.GetWaterDepth(((Component)Owner).transform.position, waves: false, volumes: false) >= 0.3f;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Rust.Ai.Gen2;

[Serializable]
internal class Trans_TargetIsInSafeZone : FSMTransitionBase
{
	protected override bool EvaluateInternal()
	{
		TimeWarning val = TimeWarning.New("Trans_TargetIsInSafeZone", 0);
		try
		{
			BaseEntity target;
			return base.Senses.FindTarget(out target) && target.InSafeZone();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.Diagnostics;
using ConVar;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;

[SoftRequireComponent(typeof(NavMeshAgent))]
public class LimitedTurnNavAgent : EntityComponent<BaseEntity>
{
	public enum Speeds
	{
		Sneak,
		Walk,
		Jog,
		Run,
		Sprint,
		FullSprint
	}

	[SerializeField]
	private NavMeshAgent agent;

	[SerializeField]
	[Header("Speed")]
	private float sneakSpeed = 0.6f;

	[SerializeField]
	private float walkSpeed = 0.89f;

	[SerializeField]
	private float jogSpeed = 2.45f;

	[SerializeField]
	private float runSpeed = 4.4f;

	[SerializeField]
	private float sprintSpeed = 6f;

	[SerializeField]
	private float fullSprintSpeed = 9f;

	[SerializeField]
	public bool canSwim;

	[SerializeField]
	private float swimSpeed = 0.6f;

	[SerializeField]
	private float swimSprintSpeed = 0.89f;

	public ResettableFloat desiredSwimDepth = new ResettableFloat(0.7f);

	public ResettableFloat acceleration = new ResettableFloat(10f);

	public ResettableFloat deceleration = new ResettableFloat(2f);

	[SerializeField]
	private float maxTurnRadius = 2f;

	[SerializeField]
	private Enum preferedTopology = (Enum)537002081;

	[SerializeField]
	private Enum preferedBiome = (Enum)15;

	public const BaseEntity.Flags FLAG_IS_SWIMMING = BaseEntity.Flags.Reserved1;

	public const BaseEntity.Flags FLAG_IS_JUMPING = BaseEntity.Flags.Reserved2;

	private const float emergencyDeceleration = 10f;

	private static NavMeshPath path;

	[NonSerialized]
	public UnityEvent onPathFailed = new UnityEvent();

	private LockState movementLock = new LockState();

	private bool isNavMeshReady;

	private int? lastFrameCall;

	private static ListHashSet<LimitedTurnNavAgent> steeringComponents = new ListHashSet<LimitedTurnNavAgent>();

	[NonSerialized]
	public float currentDeviation;

	[NonSerialized]
	public bool shouldStopAtDestination = true;

	private float cachedPathLength;

	private Vector3? previousLocalPosition;

	private float curSpeed;

	private float desiredSpeed;

	public bool IsSwimming
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved1);
		}
		private set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved1, value);
		}
	}

	public bool IsJumping
	{
		get
		{
			return base.baseEntity.flags.HasFlag(BaseEntity.Flags.Reserved2);
		}
		set
		{
			base.baseEntity.SetFlag(BaseEntity.Flags.Reserved2, value);
		}
	}

	public Vector3 NavPosition => agent.nextPosition;

	public bool isPaused => movementLock.IsLocked;

	public bool IsNavmeshReady => isNavMeshReady;

	public Vector3? lastValidDestination { get; private set; }

	public float RemainingDistance => agent.remainingDistance;

	public bool IsFollowingPath
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (agent.hasPath)
			{
				return agent.remainingDistance > (shouldStopAtDestination ? ((Bounds)(ref base.baseEntity.bounds)).extents.z : maxTurnRadius);
			}
			return false;
		}
	}

	public LockState.LockHandle Pause()
	{
		if (!movementLock.IsLocked)
		{
			OnPaused();
		}
		return movementLock.AddLock();
	}

	public bool Unpause(ref LockState.LockHandle handle)
	{
		bool result = movementLock.RemoveLock(ref handle);
		if (!movementLock.IsLocked)
		{
			OnUnpaused();
		}
		return result;
	}

	public void Move(Vector3 offset)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Move", 0);
		try
		{
			if (AI.logIssues && lastFrameCall.HasValue && lastFrameCall == Time.frameCount)
			{
				StackTrace stackTrace = new StackTrace();
				Debug.LogError((object)("Move called multiple times in the same frame\n" + stackTrace.ToString()));
			}
			agent.Move(offset);
			lastFrameCall = Time.frameCount;
			if (canSwim)
			{
				Vector3 nextPosition = agent.nextPosition;
				WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(nextPosition, waves: false, volumes: false);
				IsSwimming = waterInfo.currentDepth > desiredSwimDepth.Value;
				if (IsSwimming)
				{
					nextPosition.y = ((Component)base.baseEntity).transform.position.y;
					nextPosition.y = Mathf.MoveTowards(nextPosition.y, waterInfo.surfaceLevel - desiredSwimDepth.Value, 1f * Time.deltaTime);
					nextPosition.y = Mathf.Max(nextPosition.y, waterInfo.terrainHeight);
					((Component)base.baseEntity).transform.position = nextPosition;
				}
				else
				{
					((Component)base.baseEntity).transform.position = agent.nextPosition;
				}
			}
			else
			{
				IsSwimming = false;
				((Component)base.baseEntity).transform.position = agent.nextPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ResetPath()
	{
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:ResetPath", 0);
		try
		{
			shouldStopAtDestination = true;
			acceleration.Reset();
			deceleration.Reset();
			currentDeviation = 0f;
			SetSpeed(0f);
			if (agent.hasPath)
			{
				agent.ResetPath();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CanReach(Vector3 location, bool resetPathOnFailure = false)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Invalid comparison between Unknown and I4
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:CanReach", 0);
		try
		{
			if (!IsPositionOnNavmesh(location, out var sample))
			{
				FailPath(location, null, resetPathOnFailure);
				return false;
			}
			if (!CalculatePathCustom(sample, path))
			{
				FailPath(sample, path, resetPathOnFailure);
				return false;
			}
			bool flag = (int)path.status == 0;
			if (!flag)
			{
				FailPath(sample, path, resetPathOnFailure);
			}
			else if (flag && resetPathOnFailure)
			{
				lastValidDestination = path.GetDestination();
			}
			return flag;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SetDestination(Vector3 newDestination, bool resetPathOnFailure = false)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetDestination", 0);
		try
		{
			if (shouldStopAtDestination && agent.hasPath && Vector3.Distance(agent.destination, newDestination) < 1f)
			{
				return true;
			}
			if (!CalculatePathCustom(newDestination, path))
			{
				FailPath(newDestination, path, resetPathOnFailure);
				return false;
			}
			if ((int)path.status != 0)
			{
				FailPath(newDestination, path, resetPathOnFailure);
				return false;
			}
			SetPath(path);
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		base.InitShared();
		if (path == null)
		{
			path = new NavMeshPath();
		}
	}

	private void OnPaused()
	{
		if (((Behaviour)agent).enabled && agent.isOnNavMesh)
		{
			ResetPath();
		}
	}

	private void OnUnpaused()
	{
	}

	private void SetPath(NavMeshPath newPath)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:SetPath", 0);
		try
		{
			if (agent.path != newPath)
			{
				agent.SetPath(newPath);
			}
			cachedPathLength = newPath.GetPathLength();
			lastValidDestination = newPath.GetDestination();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void ShowFailedPath(Vector3? destination, NavMeshPath failedPath)
	{
	}

	private void FailPath(Vector3? destination, NavMeshPath failedPath = null, bool resetPathOnFailure = false)
	{
		ShowFailedPath(destination, failedPath);
		if (resetPathOnFailure)
		{
			onPathFailed.Invoke();
			ResetPath();
		}
	}

	private float GetSpeedForGait(Speeds gait)
	{
		return gait switch
		{
			Speeds.Sneak => sneakSpeed, 
			Speeds.Walk => walkSpeed, 
			Speeds.Jog => jogSpeed, 
			Speeds.Run => runSpeed, 
			Speeds.Sprint => sprintSpeed, 
			Speeds.FullSprint => fullSprintSpeed, 
			_ => walkSpeed, 
		};
	}

	public void SetSpeed(Speeds gait)
	{
		SetSpeed(GetSpeedForGait(gait));
	}

	public bool IsSpeedGTE(Speeds minGait)
	{
		return curSpeed >= GetSpeedForGait(minGait) - 0.01f;
	}

	public void SetSpeed(float speed)
	{
		desiredSpeed = speed;
	}

	public void SetSpeedRatio(float ratio, Speeds minSpeed = Speeds.Sneak, Speeds maxSpeed = Speeds.Sprint, int offset = 0)
	{
		int num = Mathf.FloorToInt(Mathf.Lerp((float)minSpeed, (float)maxSpeed, ratio));
		num = Mathf.Clamp(num + offset, (int)minSpeed, (int)maxSpeed);
		SetSpeed((Speeds)num);
	}

	private void OnEnable()
	{
		steeringComponents.TryAdd(this);
	}

	private void OnDisable()
	{
		steeringComponents.Remove(this);
	}

	public static void TickSteering()
	{
		for (int num = steeringComponents.Count - 1; num >= 0; num--)
		{
			LimitedTurnNavAgent limitedTurnNavAgent = steeringComponents[num];
			if (limitedTurnNavAgent.IsUnityNull() || !limitedTurnNavAgent.baseEntity.IsValid())
			{
				steeringComponents.RemoveAt(num);
			}
			else
			{
				limitedTurnNavAgent.Tick();
			}
		}
	}

	private void Tick()
	{
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("LimitedTurnNavAgent:Tick", 0);
		try
		{
			try
			{
				if (!AI.move)
				{
					return;
				}
				if (!isNavMeshReady)
				{
					isNavMeshReady = (Object)(object)agent != (Object)null && ((Behaviour)agent).enabled && agent.isOnNavMesh;
					if (!isNavMeshReady)
					{
						return;
					}
					agent.updateRotation = false;
					agent.updatePosition = false;
					agent.updateUpAxis = false;
					agent.isStopped = true;
				}
				if (movementLock.IsLocked)
				{
					if (previousLocalPosition.HasValue)
					{
						Vector3 val2 = ((Component)base.baseEntity).transform.localPosition - previousLocalPosition.Value;
						curSpeed = ((Vector3)(ref val2)).magnitude / Time.deltaTime;
					}
					return;
				}
				if (IsSwimming && curSpeed > swimSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{swimSprintSpeed}");
					}
					curSpeed = swimSpeed;
				}
				else if (!IsSwimming && curSpeed > fullSprintSpeed)
				{
					if (AI.logIssues)
					{
						Debug.LogError((object)$"Speed is too high: {curSpeed}/{fullSprintSpeed}");
					}
					curSpeed = fullSprintSpeed;
				}
				if (!shouldStopAtDestination || IsFollowingPath)
				{
					SteerTowardsWaypoint();
					return;
				}
				curSpeed = Mathf.Max(desiredSpeed, curSpeed - 10f * Time.deltaTime);
				ResetPath();
			}
			finally
			{
				previousLocalPosition = ((Component)base.baseEntity).transform.localPosition;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static float GetBrakingDistance(float speed, float brakingDeceleration)
	{
		float num = speed / Mathf.Max(brakingDeceleration, 0.001f);
		return 0.5f * brakingDeceleration * num * num;
	}

	private float AdjustSpeedForSwimming(float speed)
	{
		if (!IsSwimming || speed <= 0f)
		{
			return speed;
		}
		if (!(speed < sprintSpeed))
		{
			return swimSprintSpeed;
		}
		return swimSpeed;
	}

	private void SteerTowardsWaypoint()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SteerTowardsWaypoint", 0);
		try
		{
			Transform transform = ((Component)base.baseEntity).transform;
			Vector3 val2 = agent.steeringTarget - transform.position;
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			if (Mathf.Abs(cachedPathLength - Vector3.Distance(transform.position, agent.destination)) < 5f)
			{
				val3 = Quaternion.AngleAxis(currentDeviation, Vector3.up) * val3;
			}
			float num = AdjustSpeedForSwimming(desiredSpeed);
			if (shouldStopAtDestination && agent.remainingDistance - maxTurnRadius < GetBrakingDistance(curSpeed, deceleration.Value))
			{
				curSpeed = Mathf.Max(1f, curSpeed - deceleration.Value * Time.deltaTime);
			}
			else if (curSpeed > num)
			{
				float num2 = (curSpeed - num) / deceleration.Value;
				float num3 = ((curSpeed > walkSpeed && num2 > 1f) ? 10f : deceleration.Value);
				curSpeed = Mathf.Max(num, curSpeed - num3 * Time.deltaTime);
			}
			else if (curSpeed < num)
			{
				curSpeed = Mathf.Min(num, curSpeed + acceleration.Value * Time.deltaTime);
			}
			agent.isStopped = true;
			if (!(((Vector3)(ref val3)).magnitude < 0.01f))
			{
				float num4 = (shouldStopAtDestination ? Mathx.RemapValClamped(agent.remainingDistance, maxTurnRadius * 2f, 0f, maxTurnRadius, 0.001f) : maxTurnRadius);
				float num5 = curSpeed / num4;
				Vector3 val4 = Vector3.RotateTowards(transform.forward, val3, num5 * Time.deltaTime, 0f);
				Vector3 offset = val4 * (curSpeed * Time.deltaTime);
				transform.rotation = Quaternion.LookRotation(Vector3Ex.WithY(val4, 0f));
				Move(offset);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnNavmesh(Vector3 position, out Vector3 sample)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return SamplePosition(position, out sample, 0.5f);
	}

	public bool SampleGroundPositionWithPhysics(Vector3 position, out RaycastHit hitInfo, float maxDistance = 2f, float radius = 0f, int layerMask = 1503731969)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SampleGroundPositionWithPhysics", 0);
		try
		{
			Vector3 val2 = position + Vector3.up * radius * 1.5f;
			float maxDistance2 = maxDistance + radius * 1.5f;
			if (!GamePhysics.TraceRealm(GamePhysics.Realm.Server, new Ray(val2, Vector3.down), radius, out hitInfo, maxDistance2, layerMask, (QueryTriggerInteraction)1))
			{
				((RaycastHit)(ref hitInfo)).point = position;
				return false;
			}
			if (radius > 0f && ((RaycastHit)(ref hitInfo)).distance <= 0f)
			{
				((RaycastHit)(ref hitInfo)).point = position;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionOnFavoredTerrain(Vector3 position)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionOnFavoredTerrain", 0);
		try
		{
			return IsPositionAtTopologyRequirement(position, preferedTopology) && IsPositionABiomeRequirement(position, preferedBiome);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionAtTopologyRequirement(Vector3 position, Enum topologyRequirement)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionAtTopologyRequirement", 0);
		try
		{
			if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.TopologyMap.GetTopology(position);
			if ((topologyRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsPositionABiomeRequirement(Vector3 position, Enum biomeRequirement)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsPositionABiomeRequirement", 0);
		try
		{
			if ((int)biomeRequirement == 0)
			{
				return true;
			}
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return false;
			}
			Enum val2 = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			if ((biomeRequirement & val2) == 0)
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInWater(Vector3 position)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInWater", 0);
		try
		{
			if (WaterLevel.GetOverallWaterDepth(position, waves: false, volumes: false) >= 0.3f)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool SamplePosition(Vector3 position, out Vector3 sample, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SamplePosition", 0);
		try
		{
			sample = position;
			NavMeshHit val2 = default(NavMeshHit);
			if (!NavMesh.SamplePosition(position, ref val2, maxDistance, agent.areaMask))
			{
				return false;
			}
			sample = ((NavMeshHit)(ref val2)).position;
			return ((NavMeshHit)(ref val2)).hit;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool Raycast(Vector3 targetPosition, out NavMeshHit hitInfo)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Raycast", 0);
		try
		{
			return agent.Raycast(targetPosition, ref hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool CalculatePathCustom(Vector3 destination, NavMeshPath path)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CalculatePathCustom", 0);
		try
		{
			return agent.CalculatePath(destination, path);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public enum Speeds
{
	Sneak,
	Walk,
	Jog,
	Run,
	Sprint,
	FullSprint
}


using System;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshPathEx
{
	private static Vector3[] cornersBuffer = (Vector3[])(object)new Vector3[128];

	public static float GetPathLength(this NavMeshPath path)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPathLength", 0);
		try
		{
			float num = 0f;
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 2)
			{
				return num;
			}
			for (int i = 0; i < cornersNonAlloc - 1; i++)
			{
				num += Vector3.Distance(cornersBuffer[i], cornersBuffer[i + 1]);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetOrigin(this NavMeshPath path)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetOrigin", 0);
		try
		{
			if (path.GetCornersNonAlloc(cornersBuffer) < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[0];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetDestination(this NavMeshPath path)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetDestination", 0);
		try
		{
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[cornersNonAlloc - 1];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using ConVar;
using Rust;
using UnityEngine;

public class BaseNPC2 : BaseCombatEntity
{
	[SerializeField]
	private float mass = 45f;

	public override bool IsNpc => true;

	public bool IsAnimal => true;

	public override float RealisticMass => mass;

	public string displayName
	{
		get
		{
			PrefabInformation prefabInformation = null;
			if (base.isServer)
			{
				prefabInformation = PrefabAttribute.server.Find<PrefabInformation>(prefabID);
			}
			if (prefabInformation == null)
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)("PrefabInformation not found for " + Categorize() + ")"));
				}
				return "NPC";
			}
			return prefabInformation.title.english;
		}
	}

	public override float MaxVelocity()
	{
		return 10f;
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			Query.Server.AddBrain(this);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && !Application.isQuitting)
		{
			Query.Server.RemoveBrain(this);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

[SoftRequireComponent(typeof(SenseComponent))]
public class NPCEncounterTimer : EntityComponent<BaseEntity>, IServerComponent
{
	public float giveUpDurationSeconds = 120f;

	[NonSerialized]
	public UnityEvent onShouldGiveUp = new UnityEvent();

	private const float fireTimeMultiplier = 4f;

	private const float mountedTimeMultiplier = 12f;

	private float? encounterRemainingTimeSeconds;

	private double? _lastTickTime;

	private SenseComponent _senseComponent;

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	private SenseComponent Senses => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	public void Tick()
	{
		float num = (float)(Time.timeAsDouble - LastTickTime);
		LastTickTime = Time.timeAsDouble;
		BaseEntity target;
		bool flag = Senses.FindTarget(out target);
		if (encounterRemainingTimeSeconds.HasValue && !flag)
		{
			encounterRemainingTimeSeconds = null;
		}
		else if (!encounterRemainingTimeSeconds.HasValue && flag)
		{
			StartTimer();
		}
		else
		{
			if (!encounterRemainingTimeSeconds.HasValue)
			{
				return;
			}
			if (base.baseEntity is BaseCombatEntity { SecondsSinceAttacked: <5f })
			{
				StartTimer();
				PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Senses.GetInitialAllies((List<BaseEntity>)(object)val);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val)
					{
						((Component)item).GetComponent<NPCEncounterTimer>().StartTimer();
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			float num2 = 1f;
			if (target.ToNonNpcPlayer(out var player) && player.isMounted)
			{
				num2 = 12f;
			}
			else if (Trans_TargetIsNearFire.Test(base.baseEntity, Senses))
			{
				num2 = 4f;
			}
			encounterRemainingTimeSeconds -= num * num2;
			if (!(encounterRemainingTimeSeconds <= 0f))
			{
				return;
			}
			GiveUp();
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					((Component)item2).GetComponent<NPCEncounterTimer>().GiveUp();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	private void StartTimer()
	{
		encounterRemainingTimeSeconds = giveUpDurationSeconds;
	}

	private void GiveUp()
	{
		if (encounterRemainingTimeSeconds.HasValue)
		{
			encounterRemainingTimeSeconds = null;
			onShouldGiveUp.Invoke();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/AI/NPC team", fileName = "NPCTeam_new", order = 0)]
public class NPCTeam : BaseScriptableObject
{
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class RootMotionPlayer : EntityComponent<BaseEntity>, IServerComponent
{
	public struct Warp
	{
		public float startTime;

		public float endTime;

		public Vector3 translationScale;

		public float rotationScale;

		public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.startTime = startTime;
			this.endTime = endTime;
			this.translationScale = translationScale;
			this.rotationScale = rotationScale;
		}
	}

	public class PlayServerState : IPooled
	{
		public AnimationClip animClip;

		public RootMotionData rmData;

		public float elapsedTime;

		public Vector3 initialLocation;

		public Quaternion initialRotation;

		public Action ServerTickAction;

		public Warp[] warps;

		public bool constrainToNavmesh;

		public Vector3 lastUnscaledOffset;

		public float lastUnscaledRotation;

		public bool isPlaying;

		public void Reset()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			isPlaying = false;
			rmData = null;
			animClip = null;
			initialRotation = Quaternion.identity;
			warps = null;
			constrainToNavmesh = true;
			elapsedTime = 0f;
			ServerTickAction = null;
			lastUnscaledOffset = Vector3.zero;
			lastUnscaledRotation = 0f;
		}

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
			Reset();
		}

		public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.rmData = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.animClip = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public int GetAnimHash()
		{
			if (rmData != null)
			{
				if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
				{
					Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
				}
				return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
			}
			if ((Object)(object)animClip == (Object)null)
			{
				Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
			}
			return Animator.StringToHash(((Object)animClip).name);
		}

		public float GetAnimLength()
		{
			if (!(rmData != null))
			{
				return animClip.length;
			}
			return rmData.inPlaceAnimation.length;
		}

		public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			if (elapsedTime >= GetAnimLength())
			{
				return false;
			}
			if (rmData == null)
			{
				elapsedTime += deltaTime;
				return elapsedTime < GetAnimLength() - 0.25f;
			}
			Vector3 zero = Vector3.zero;
			zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
			zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
			zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
			float num = rmData.yRotationCurve.Evaluate(elapsedTime);
			Vector3 val = zero - lastUnscaledOffset;
			float num2 = num - lastUnscaledRotation;
			lastUnscaledOffset = zero;
			lastUnscaledRotation = num;
			if (warps != null)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
					{
						val.x *= warp.translationScale.x;
						val.y *= warp.translationScale.y;
						val.z *= warp.translationScale.z;
						num2 *= warp.rotationScale;
					}
				}
			}
			Vector3 val2 = initialRotation * val;
			location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			location += val2;
			rotation *= Quaternion.Euler(0f, num2, 0f);
			location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}

		public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
			initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
			rotation *= Quaternion.Inverse(rotation) * initialRotation;
			return rotation;
		}
	}

	[SerializeField]
	private float rootBoneLocalZOffset;

	private LimitedTurnNavAgent _agent;

	private PlayServerState currentPlayState;

	private Action _playServerTickAction;

	private LockState.LockHandle lockHandle;

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	private Action PlayServerTickAction => PlayServerTick;

	public PlayServerState PlayServerAndTakeFromPool(RootMotionData data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public PlayServerState PlayServerAndTakeFromPool(AnimationClip data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public void PlayServer(PlayServerState state)
	{
		if (AI.logIssues && state.rmData == null && (Object)(object)state.animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: state.rmData and state.animClip are both null");
			return;
		}
		if (currentPlayState != null)
		{
			StopServer(currentPlayState);
		}
		currentPlayState = state;
		currentPlayState.isPlaying = true;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayMontageDelayed"), currentPlayState.GetAnimHash());
		lockHandle = Agent.Pause();
		((FacepunchBehaviour)base.baseEntity).InvokeRepeating(PlayServerTickAction, 0f, 0f);
	}

	public void PlayServerAdditive(AnimationClip animClip)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayAdditiveMontage"), Animator.StringToHash(((Object)animClip).name));
	}

	private void PlayServerTick()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RootMotionPlayer:PlayServerTick", 0);
		try
		{
			Vector3 location = ((Component)base.baseEntity).transform.position;
			Quaternion rotation = ((Component)base.baseEntity).transform.rotation;
			bool num = !currentPlayState.Step(Time.deltaTime, ref location, ref rotation, rootBoneLocalZOffset);
			if (currentPlayState.rmData != null)
			{
				if (currentPlayState.constrainToNavmesh)
				{
					Agent.Move(location - ((Component)base.baseEntity).transform.position);
				}
				else
				{
					((Component)base.baseEntity).transform.position = location;
				}
				((Component)base.baseEntity).transform.rotation = rotation;
			}
			if (num)
			{
				StopServer(currentPlayState, interrupt: false);
				currentPlayState = null;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Track(Vector3 targetPos, float trackingSpeed = 45f, float? timeStep = null)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (currentPlayState != null && !(currentPlayState.rmData == null))
		{
			if (!timeStep.HasValue)
			{
				timeStep = Time.deltaTime;
			}
			((Component)base.baseEntity).transform.rotation = currentPlayState.Track(((Component)this).transform.position, targetPos, ((Component)base.baseEntity).transform.rotation, trackingSpeed, timeStep.Value);
		}
	}

	private void StopServer(PlayServerState state, bool interrupt = true)
	{
		if (state != null && state.isPlaying)
		{
			state.isPlaying = false;
			if (state == currentPlayState)
			{
				((FacepunchBehaviour)base.baseEntity).CancelInvoke(PlayServerTickAction);
				Agent.Unpause(ref lockHandle);
				currentPlayState = null;
			}
			if (interrupt)
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_StopMontage"));
			}
		}
	}

	public void StopServerAndReturnToPool(ref PlayServerState state, bool interrupt = true)
	{
		if (state != null)
		{
			StopServer(state, interrupt);
			Pool.Free<PlayServerState>(ref state);
		}
	}
}


using UnityEngine;

public struct Warp
{
	public float startTime;

	public float endTime;

	public Vector3 translationScale;

	public float rotationScale;

	public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.startTime = startTime;
		this.endTime = endTime;
		this.translationScale = translationScale;
		this.rotationScale = rotationScale;
	}
}


using System;
using Facepunch;
using UnityEngine;

public class PlayServerState : IPooled
{
	public AnimationClip animClip;

	public RootMotionData rmData;

	public float elapsedTime;

	public Vector3 initialLocation;

	public Quaternion initialRotation;

	public Action ServerTickAction;

	public Warp[] warps;

	public bool constrainToNavmesh;

	public Vector3 lastUnscaledOffset;

	public float lastUnscaledRotation;

	public bool isPlaying;

	public void Reset()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		isPlaying = false;
		rmData = null;
		animClip = null;
		initialRotation = Quaternion.identity;
		warps = null;
		constrainToNavmesh = true;
		elapsedTime = 0f;
		ServerTickAction = null;
		lastUnscaledOffset = Vector3.zero;
		lastUnscaledRotation = 0f;
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}

	public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.rmData = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.animClip = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public int GetAnimHash()
	{
		if (rmData != null)
		{
			if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
			{
				Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
			}
			return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
		}
		if ((Object)(object)animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
		}
		return Animator.StringToHash(((Object)animClip).name);
	}

	public float GetAnimLength()
	{
		if (!(rmData != null))
		{
			return animClip.length;
		}
		return rmData.inPlaceAnimation.length;
	}

	public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		if (elapsedTime >= GetAnimLength())
		{
			return false;
		}
		if (rmData == null)
		{
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}
		Vector3 zero = Vector3.zero;
		zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
		zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
		zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
		float num = rmData.yRotationCurve.Evaluate(elapsedTime);
		Vector3 val = zero - lastUnscaledOffset;
		float num2 = num - lastUnscaledRotation;
		lastUnscaledOffset = zero;
		lastUnscaledRotation = num;
		if (warps != null)
		{
			Warp[] array = warps;
			for (int i = 0; i < array.Length; i++)
			{
				Warp warp = array[i];
				if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
				{
					val.x *= warp.translationScale.x;
					val.y *= warp.translationScale.y;
					val.z *= warp.translationScale.z;
					num2 *= warp.rotationScale;
				}
			}
		}
		Vector3 val2 = initialRotation * val;
		location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		location += val2;
		rotation *= Quaternion.Euler(0f, num2, 0f);
		location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		elapsedTime += deltaTime;
		return elapsedTime < GetAnimLength() - 0.25f;
	}

	public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
		initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
		rotation *= Quaternion.Inverse(rotation) * initialRotation;
		return rotation;
	}
}


using UnityEngine;

public class RootMotionTester : MonoBehaviour
{
	public RootMotionData anim;

	public Transform target;

	public float timeStep = 0.1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 1f;

	public float rotArrowLength = 0.2f;

	public float targetVelocityYaw = 45f;

	public float targetVelocityMagnitude = 5f;

	public int trackingStepIndex;

	public float parentFrontOffset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class SenseComponent : EntityComponent<BaseEntity>
{
	[Serializable]
	public struct Cone
	{
		public float halfAngle;

		public float range;

		public Cone(float halfAngle = 80f, float range = 10f)
		{
			this.halfAngle = halfAngle;
			this.range = range;
		}
	}

	public class VisibilityStatus : IPooled
	{
		private BaseEntity baseEntity;

		private BaseEntity targetEntity;

		public Vector3 lastKnownPosition;

		private const float waterCheckInterval = 1f;

		private double? lastTimeInWaterUpdated;

		public float timeVisible { get; private set; }

		public float timeNotVisible { get; private set; }

		public bool isVisible => timeVisible > 0f;

		public float timeWatched { get; private set; }

		public float timeNotWatched { get; private set; }

		public float timeAimedAt { get; private set; }

		public float timeNotAimedAt { get; private set; }

		public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

		public bool isInWaterCached
		{
			get
			{
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_008c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				if (!targetEntity.ToNonNpcPlayer(out var player))
				{
					return false;
				}
				if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
				{
					BaseMountable entAsT;
					Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
					lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
					lastTimeInWaterUpdated = Time.timeAsDouble;
				}
				return lastWaterInfo.Value.currentDepth >= 0.3f;
			}
		}

		private void Reset()
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			targetEntity = null;
			baseEntity = null;
			timeWatched = 0f;
			timeNotWatched = 100f;
			timeAimedAt = 0f;
			timeNotAimedAt = 100f;
			timeVisible = 0f;
			timeNotVisible = 100f;
			lastKnownPosition = Vector3.zero;
			lastWaterInfo = null;
			lastTimeInWaterUpdated = null;
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
			visibilityStatus.baseEntity = baseEntity;
			visibilityStatus.targetEntity = targetEntity;
			visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
			return visibilityStatus;
		}

		private bool CheckValid()
		{
			if (!baseEntity.IsValid() || !targetEntity.IsValid())
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
				}
				return false;
			}
			return true;
		}

		public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			if (!CheckValid())
			{
				return;
			}
			if (lastKnownPositionOverride.HasValue)
			{
				lastKnownPosition = lastKnownPositionOverride.Value;
			}
			else if (isVisible)
			{
				lastKnownPosition = ((Component)targetEntity).transform.position;
			}
			if (isVisible)
			{
				timeNotVisible = 0f;
				timeVisible += deltaTime;
				Vector3 val = ((Component)targetEntity).transform.forward;
				Vector3 position = ((Component)targetEntity).transform.position;
				if (targetEntity.ToNonNpcPlayer(out var player))
				{
					val = player.eyes.HeadForward();
					position = player.eyes.position;
				}
				Vector3 val2 = ((Component)baseEntity).transform.position - position;
				float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
				bool num2 = num < AI.watchedAngle;
				if (num2)
				{
					timeNotWatched = 0f;
					timeWatched += deltaTime;
				}
				else
				{
					timeWatched = 0f;
					timeNotWatched += deltaTime;
				}
				if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
				{
					timeNotAimedAt = 0f;
					timeAimedAt += deltaTime;
				}
				else
				{
					timeAimedAt = 0f;
					timeNotAimedAt += deltaTime;
				}
			}
			else
			{
				timeVisible = 0f;
				timeNotVisible += deltaTime;
				timeWatched = 0f;
				timeNotWatched += deltaTime;
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
	}

	[SerializeField]
	private Vector3 LongRangeVisionRectangle = new Vector3(6f, 30f, 60f);

	[SerializeField]
	private Cone ShortRangeVisionCone = new Cone(100f, 30f);

	[SerializeField]
	private float touchDistance = 6f;

	[SerializeField]
	private float noiseRangeMultiplier = 1f;

	[SerializeField]
	private float hearingRange = 50f;

	[SerializeField]
	private NPCTeam team;

	[NonSerialized]
	public ResettableFloat timeToForgetSightings = new ResettableFloat(30f);

	private const float timeToForgetNoises = 5f;

	private static HashSet<BaseEntity> entitiesUpdatedThisFrame = new HashSet<BaseEntity>();

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0.2f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 1f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private double spawnTime;

	private Dictionary<BaseEntity, double> _alliesWeAreAwareOf = new Dictionary<BaseEntity, double>(3);

	private Dictionary<BaseEntity, VisibilityStatus> entitiesWeAreAwareOf = new Dictionary<BaseEntity, VisibilityStatus>(8);

	private static readonly Dictionary<NpcNoiseIntensity, float> noiseRadii = new Dictionary<NpcNoiseIntensity, float>
	{
		{
			NpcNoiseIntensity.None,
			0f
		},
		{
			NpcNoiseIntensity.Low,
			10f
		},
		{
			NpcNoiseIntensity.Medium,
			20f
		},
		{
			NpcNoiseIntensity.High,
			50f
		}
	};

	private NpcNoiseEvent _currentNoise;

	[SerializeField]
	private float foodDetectionRange = 30f;

	private BaseEntity _nearestFood;

	[SerializeField]
	private float fireDetectionRange = 20f;

	[NonSerialized]
	public UnityEvent onFireMelee = new UnityEvent();

	private BaseEntity _nearestFire;

	private double? lastMeleeTime;

	[SerializeField]
	private float TargetingCooldown = 5f;

	private BaseEntity _target;

	private const float npcDistPenaltyToFavorTargetingPlayers = 10f;

	private double? lastTargetTime;

	private LockState lockState = new LockState();

	public float RefreshInterval
	{
		get
		{
			if (!ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public bool HasPlayerInVicinity { get; private set; }

	public bool ShouldRefreshFast
	{
		get
		{
			if (!HasPlayerInVicinity)
			{
				if ((Object)(object)Target != (Object)null)
				{
					return Target.IsNonNpcPlayer();
				}
				return false;
			}
			return true;
		}
	}

	public NpcNoiseEvent currentNoise => _currentNoise;

	private BaseEntity Target
	{
		get
		{
			return _target;
		}
		set
		{
			if (base.baseEntity.isServer)
			{
				BaseEntity target = _target;
				_target = value;
				if ((Object)(object)target != (Object)(object)_target)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	private bool ChangedTargetRecently
	{
		get
		{
			if (lastTargetTime.HasValue)
			{
				return Time.timeAsDouble - lastTargetTime.Value < (double)TargetingCooldown;
			}
			return true;
		}
	}

	public void GetInitialAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, num2) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (baseEntity2 is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else if (!(num2 - spawnTime > (double)(maxRefreshIntervalSeconds * 2f)))
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3? GetLKP(BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (GetVisibilityStatus(entity, out var status))
		{
			return status.isVisible ? ((Component)entity).transform.position : status.lastKnownPosition;
		}
		return null;
	}

	public bool GetVisibilityStatus(BaseEntity entity, out VisibilityStatus status)
	{
		status = null;
		if (!CanTarget(entity))
		{
			return false;
		}
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out status))
		{
			return false;
		}
		return true;
	}

	public bool Forget(BaseEntity entity)
	{
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			return false;
		}
		entitiesWeAreAwareOf.Remove(entity);
		Pool.Free<VisibilityStatus>(ref value);
		return true;
	}

	public bool IsVisible(BaseEntity entity)
	{
		if (!GetVisibilityStatus(entity, out var status))
		{
			return false;
		}
		return status.isVisible;
	}

	public void GetSeenEntities(List<BaseEntity> perceivedEntities)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:GetSeenEntities", 0);
		try
		{
			foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
			{
				if (IsVisible(key))
				{
					perceivedEntities.Add(key);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetOncePerceivedEntities(List<BaseEntity> perceivedEntities)
	{
		foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
		{
			if (GetVisibilityStatus(key, out var _))
			{
				perceivedEntities.Add(key);
			}
		}
	}

	private Matrix4x4 GetEyeTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		return Matrix4x4.TRS(base.baseEntity.CenterPoint(), ((Component)base.baseEntity).transform.rotation, Vector3.one);
	}

	public override void InitShared()
	{
		base.InitShared();
		spawnTime = Time.timeAsDouble;
	}

	public override void Hurt(HitInfo hitInfo)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity initiator = hitInfo.Initiator;
		if (!CanTarget(initiator))
		{
			return;
		}
		Vector3 val = ((Component)initiator).transform.position + Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.up) * Vector3.forward * 5f;
		if (entitiesWeAreAwareOf.TryGetValue(initiator, out var value))
		{
			if (!value.isVisible && value.timeNotVisible > 3f)
			{
				value.lastKnownPosition = val;
			}
		}
		else
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, initiator, 0.01f, val);
			entitiesWeAreAwareOf.Add(initiator, fromPool);
		}
	}

	public void Tick()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Tick", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			if (timeAsDouble < nextRefreshTime)
			{
				return;
			}
			float deltaTime = (float)(timeAsDouble - LastTickTime);
			LastTickTime = timeAsDouble;
			HasPlayerInVicinity = false;
			entitiesUpdatedThisFrame.Clear();
			TimeWarning val2 = TimeWarning.New("SenseComponent:Tick:ProcessEntities", 0);
			try
			{
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					BaseEntity.Query.Server.GetPlayersAndBrainsInSphere(((Component)base.baseEntity).transform.position, LongRangeVisionRectangle.z, (List<BaseEntity>)(object)val3, BaseEntity.Query.DistanceCheckType.None);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val3)
					{
						if (!((Object)(object)item == (Object)(object)base.baseEntity))
						{
							if (item.IsNonNpcPlayer())
							{
								HasPlayerInVicinity = true;
							}
							if (InSameTeam(item) && !_alliesWeAreAwareOf.ContainsKey(item))
							{
								_alliesWeAreAwareOf.Add(item, timeAsDouble);
							}
							if (CanTarget(item))
							{
								UpdateEntityVisibility(item, deltaTime);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			TimeWarning val4 = TimeWarning.New("SenseComponent:Tick:RemoveEntities", 0);
			try
			{
				PooledList<BaseEntity> val5 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					foreach (var (baseEntity2, visibilityStatus2) in entitiesWeAreAwareOf)
					{
						if (!CanTarget(baseEntity2))
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!visibilityStatus2.isVisible && visibilityStatus2.timeNotVisible > timeToForgetSightings.Value)
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!entitiesUpdatedThisFrame.Contains(baseEntity2) && visibilityStatus2.isVisible)
						{
							entitiesWeAreAwareOf[baseEntity2].UpdateVisibility(isVisible: false, deltaTime, null);
						}
					}
					entitiesUpdatedThisFrame.Clear();
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val5)
					{
						if (Target.IsValid() && (Object)(object)Target == (Object)(object)item2)
						{
							ClearTarget(forget: false);
						}
						Forget(item2);
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
			TickHearing(deltaTime);
			TickFoodDetection(deltaTime);
			TickFireDetection(deltaTime);
			TickTargeting(deltaTime);
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void GetModifiedSenses(BaseEntity entity, out float modTouchDistance, out float modHalfAngle, out float modShortVisionRange, out Vector3 modLongVisionRectangle)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		modTouchDistance = touchDistance;
		modHalfAngle = ShortRangeVisionCone.halfAngle;
		modShortVisionRange = ShortRangeVisionCone.range;
		modLongVisionRectangle = LongRangeVisionRectangle;
		if (entity.ToNonNpcPlayer(out var player))
		{
			if (player.IsDucked())
			{
				modTouchDistance = ((Bounds)(ref base.baseEntity.bounds)).extents.z * 1.5f;
				modHalfAngle = ShortRangeVisionCone.halfAngle * 0.85f;
				modShortVisionRange = ShortRangeVisionCone.range * 0.5f;
				modLongVisionRectangle = Vector3.Scale(LongRangeVisionRectangle, new Vector3(3f, 0.5f, 0.5f));
			}
			else if (player.IsRunning())
			{
				modTouchDistance = touchDistance * 3f;
				modHalfAngle = ShortRangeVisionCone.halfAngle;
				modShortVisionRange = ShortRangeVisionCone.range * 1.3f;
				modLongVisionRectangle = LongRangeVisionRectangle * 1.15f;
			}
		}
	}

	private bool IsInAnyRange(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInAnyRange", 0);
		try
		{
			Matrix4x4 eyeTransform = GetEyeTransform();
			Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
			eyeTransform = GetEyeTransform();
			Vector3 val2 = ((Matrix4x4)(ref eyeTransform)).rotation * Vector3.forward;
			Vector3 val3 = ((Component)entity).transform.position - position;
			float magnitude = ((Vector3)(ref val3)).magnitude;
			GetModifiedSenses(entity, out var modTouchDistance, out var modHalfAngle, out var modShortVisionRange, out var modLongVisionRectangle);
			if (magnitude < modTouchDistance)
			{
				return true;
			}
			if (Vector3.Angle(val2, ((Vector3)(ref val3)).normalized) < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					return true;
				}
				if (TOD_Sky.Instance.IsDay && magnitude < modLongVisionRectangle.z && Mathf.Abs(((Component)entity).transform.position.y - position.y) < modLongVisionRectangle.y * 0.5f)
				{
					Vector3 val4 = Vector3.Cross(val2, ((Component)entity).transform.position - position);
					if (((Vector3)(ref val4)).magnitude < modLongVisionRectangle.x * 0.5f)
					{
						return true;
					}
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateEntityVisibility(BaseEntity entity, float deltaTime)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsInAnyRange(entity);
		if (flag && entity.ToNonNpcPlayer(out var player))
		{
			TimeWarning val = TimeWarning.New("SenseComponent:ProcessEntity:CanSee", 0);
			try
			{
				Matrix4x4 eyeTransform = GetEyeTransform();
				Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
				flag = base.baseEntity.CanSee(position, player.eyes.position);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			value.UpdateVisibility(flag, deltaTime, null);
			entitiesUpdatedThisFrame.Add(entity);
		}
		else if (flag)
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, entity, deltaTime, null);
			entitiesWeAreAwareOf.Add(entity, fromPool);
			entitiesUpdatedThisFrame.Add(entity);
		}
	}

	public bool InSameTeam(BaseEntity other)
	{
		if (team != null && ((Object)(object)((Component)other).GetComponent<SenseComponent>()).Is<SenseComponent>(out SenseComponent entAsT) && team == entAsT.team)
		{
			return true;
		}
		return base.baseEntity.InSameNpcTeam(other);
	}

	private void TickHearing(float deltaTime)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickHearing", 0);
		try
		{
			if (_currentNoise != null)
			{
				Pool.Free<NpcNoiseEvent>(ref _currentNoise);
			}
			if (noiseRangeMultiplier <= 0f)
			{
				return;
			}
			PooledList<NpcNoiseEvent> val2 = Pool.Get<PooledList<NpcNoiseEvent>>();
			try
			{
				SingletonComponent<NpcNoiseManager>.Instance.GetNoisesAround(((Component)base.baseEntity).transform.position, hearingRange, (List<NpcNoiseEvent>)(object)val2);
				NpcNoiseEvent npcNoiseEvent = null;
				float? num = null;
				foreach (NpcNoiseEvent item in (List<NpcNoiseEvent>)(object)val2)
				{
					if ((Object)(object)item.Initiator == (Object)(object)base.baseEntity || !CanTarget(item.Initiator))
					{
						continue;
					}
					float num2 = (float)(Time.timeAsDouble - item.EventTime);
					if (!(num2 > 5f) && (npcNoiseEvent == null || item.Intensity >= npcNoiseEvent.Intensity))
					{
						if (!noiseRadii.TryGetValue(item.Intensity, out var value))
						{
							Debug.LogError((object)$"Unknown noise intensity: {item.Intensity}");
						}
						else if (!(Vector3.Distance(item.Position, ((Component)base.baseEntity).transform.position) > Mathf.Min(value * noiseRangeMultiplier, hearingRange)) && (npcNoiseEvent == null || item.Intensity != npcNoiseEvent.Intensity || !(num2 > num)))
						{
							npcNoiseEvent = item;
							num = num2;
						}
					}
				}
				if (npcNoiseEvent != null)
				{
					_currentNoise = Pool.Get<NpcNoiseEvent>();
					_currentNoise.Initiator = npcNoiseEvent.Initiator;
					_currentNoise.Position = npcNoiseEvent.Position;
					_currentNoise.Intensity = npcNoiseEvent.Intensity;
					if (!FindTarget(out var _))
					{
						TrySetTarget(npcNoiseEvent.Initiator);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool ConsumeCurrentNoise()
	{
		if (_currentNoise == null)
		{
			return false;
		}
		Pool.Free<NpcNoiseEvent>(ref _currentNoise);
		return true;
	}

	public bool FindFood(out BaseEntity food)
	{
		if (!_nearestFood.IsValid() || _nearestFood.IsDestroyed || !SingletonComponent<NpcFoodManager>.Instance.Contains(_nearestFood))
		{
			food = null;
			return false;
		}
		food = _nearestFood;
		return true;
	}

	private void TickFoodDetection(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFoodDetection", 0);
		try
		{
			_nearestFood = null;
			if (foodDetectionRange <= 0f)
			{
				return;
			}
			float num = foodDetectionRange * foodDetectionRange;
			float num2 = float.MaxValue;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFoodManager>.Instance.GetFoodAround(((Component)base.baseEntity).transform.position, foodDetectionRange, (List<BaseEntity>)(object)val2);
				LimitedTurnNavAgent component = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>();
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!NpcFoodManager.IsFoodImmobile(item) || (item is BaseCorpse baseCorpse && ((Object)(object)((Component)baseCorpse).GetComponent<HeadDispenser>()).Is<HeadDispenser>(out HeadDispenser entAsT) && ((Object)(object)entAsT.SourceEntity.GetEntity()).Is<BaseEntity>(out BaseEntity entAsT2) && entAsT2.InSameNpcTeam(base.baseEntity)))
					{
						continue;
					}
					if (!component.IsPositionOnNavmesh(((Component)item).transform.position, out var sample))
					{
						SingletonComponent<NpcFoodManager>.Instance.Remove(item);
						continue;
					}
					sample = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref sample)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						_nearestFood = item;
						num2 = sqrMagnitude;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindFire(out BaseEntity fire)
	{
		if (!_nearestFire.IsValid() || _nearestFire.IsDestroyed || !NpcFireManager.IsOnFire(_nearestFire))
		{
			_nearestFire = null;
		}
		fire = _nearestFire;
		return (Object)(object)fire != (Object)null;
	}

	private void TickFireDetection(float deltaTime)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFireDetection", 0);
		try
		{
			if (fireDetectionRange <= 0f)
			{
				return;
			}
			if ((Object)(object)Target != (Object)null && SingletonComponent<NpcFireManager>.Instance.DidMeleeWithFireRecently(base.baseEntity, Target, out var meleeTime) && (!lastMeleeTime.HasValue || meleeTime != lastMeleeTime.Value))
			{
				lastMeleeTime = meleeTime;
				onFireMelee.Invoke();
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)base.baseEntity).transform.position, fireDetectionRange, (List<BaseEntity>)(object)val2);
				BaseEntity baseEntity = null;
				float num = fireDetectionRange * fireDetectionRange;
				float num2 = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					Vector3 val3 = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						baseEntity = item;
						num2 = sqrMagnitude;
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					_nearestFire = baseEntity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public LockState.LockHandle LockCurrentTarget()
	{
		return lockState.AddLock();
	}

	public bool UnlockTarget(ref LockState.LockHandle handle)
	{
		return lockState.RemoveLock(ref handle);
	}

	public bool CanTarget(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (entity.IsDestroyed)
		{
			return false;
		}
		if (!entity.IsNonNpcPlayer() && !entity.IsNpc)
		{
			return false;
		}
		if (entity.IsNpcPlayer())
		{
			return false;
		}
		if (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())
		{
			return false;
		}
		if (InSameTeam(entity))
		{
			return false;
		}
		if (entity is BasePlayer item)
		{
			if (AI.ignoreplayers)
			{
				return false;
			}
			if (SimpleAIMemory.PlayerIgnoreList.Contains(item))
			{
				return false;
			}
		}
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public bool FindTarget(out BaseEntity target)
	{
		if (!CanTarget(Target))
		{
			ClearTarget();
			target = null;
			return false;
		}
		target = Target;
		return (Object)(object)target != (Object)null;
	}

	public bool FindTargetPosition(out Vector3 targetPosition)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			targetPosition = Vector3.zero;
			return false;
		}
		targetPosition = ((Component)target).transform.position;
		return true;
	}

	public bool TrySetTarget(BaseEntity newTarget, bool bypassCooldown = true)
	{
		if (lockState.IsLocked)
		{
			return false;
		}
		if ((Object)(object)newTarget == (Object)null)
		{
			ClearTarget();
			return true;
		}
		if ((Object)(object)newTarget == (Object)(object)Target)
		{
			return true;
		}
		if (!CanTarget(newTarget))
		{
			return false;
		}
		if ((Object)(object)Target != (Object)null && !bypassCooldown && ChangedTargetRecently)
		{
			return false;
		}
		lastTargetTime = Time.timeAsDouble;
		Target = newTarget;
		return true;
	}

	public void ClearTarget(bool forget = true)
	{
		if (Target.IsValid())
		{
			if (forget)
			{
				Forget(Target);
			}
			lastTargetTime = null;
			Target = null;
		}
	}

	private void TickTargeting(float deltaTime)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:TickTargeting", 0);
		try
		{
			if ((Object)(object)Target != (Object)null && !CanTarget(Target))
			{
				ClearTarget();
			}
			if ((Object)(object)Target != (Object)null && ChangedTargetRecently)
			{
				return;
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				GetOncePerceivedEntities((List<BaseEntity>)(object)val2);
				if (((List<BaseEntity>)(object)val2).Count == 0)
				{
					return;
				}
				BaseEntity baseEntity = null;
				float num = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (CanTarget(item))
					{
						float num2 = base.baseEntity.SqrDistance(item);
						if (item.IsNpc)
						{
							num2 += 100f;
						}
						if (num2 < num)
						{
							num = num2;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					TrySetTarget(baseEntity, bypassCooldown: false);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.SaveComponent(info);
		if (base.baseEntity.isServer)
		{
			info.msg.npcSensesState = Pool.Get<NPCSensesState>();
			if ((Object)(object)Target != (Object)null)
			{
				info.msg.npcSensesState.targetEntityId = Target.net.ID;
			}
		}
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		NPCSensesState npcSensesState = info.msg.npcSensesState;
		if (npcSensesState != null)
		{
			if (((NetworkableId)(ref npcSensesState.targetEntityId)).IsValid)
			{
				if (base.baseEntity.isServer)
				{
					_target = BaseNetworkable.serverEntities.Find(npcSensesState.targetEntityId) as BaseEntity;
				}
			}
			else
			{
				_target = null;
			}
		}
		base.LoadComponent(info);
	}
}


using System;

[Serializable]
public struct Cone
{
	public float halfAngle;

	public float range;

	public Cone(float halfAngle = 80f, float range = 10f)
	{
		this.halfAngle = halfAngle;
		this.range = range;
	}
}


using ConVar;
using Facepunch;
using UnityEngine;

public class VisibilityStatus : IPooled
{
	private BaseEntity baseEntity;

	private BaseEntity targetEntity;

	public Vector3 lastKnownPosition;

	private const float waterCheckInterval = 1f;

	private double? lastTimeInWaterUpdated;

	public float timeVisible { get; private set; }

	public float timeNotVisible { get; private set; }

	public bool isVisible => timeVisible > 0f;

	public float timeWatched { get; private set; }

	public float timeNotWatched { get; private set; }

	public float timeAimedAt { get; private set; }

	public float timeNotAimedAt { get; private set; }

	public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

	public bool isInWaterCached
	{
		get
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			if (!targetEntity.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
			{
				BaseMountable entAsT;
				Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
				lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
				lastTimeInWaterUpdated = Time.timeAsDouble;
			}
			return lastWaterInfo.Value.currentDepth >= 0.3f;
		}
	}

	private void Reset()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		targetEntity = null;
		baseEntity = null;
		timeWatched = 0f;
		timeNotWatched = 100f;
		timeAimedAt = 0f;
		timeNotAimedAt = 100f;
		timeVisible = 0f;
		timeNotVisible = 100f;
		lastKnownPosition = Vector3.zero;
		lastWaterInfo = null;
		lastTimeInWaterUpdated = null;
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
		visibilityStatus.baseEntity = baseEntity;
		visibilityStatus.targetEntity = targetEntity;
		visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
		return visibilityStatus;
	}

	private bool CheckValid()
	{
		if (!baseEntity.IsValid() || !targetEntity.IsValid())
		{
			if (AI.logIssues)
			{
				Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
			}
			return false;
		}
		return true;
	}

	public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckValid())
		{
			return;
		}
		if (lastKnownPositionOverride.HasValue)
		{
			lastKnownPosition = lastKnownPositionOverride.Value;
		}
		else if (isVisible)
		{
			lastKnownPosition = ((Component)targetEntity).transform.position;
		}
		if (isVisible)
		{
			timeNotVisible = 0f;
			timeVisible += deltaTime;
			Vector3 val = ((Component)targetEntity).transform.forward;
			Vector3 position = ((Component)targetEntity).transform.position;
			if (targetEntity.ToNonNpcPlayer(out var player))
			{
				val = player.eyes.HeadForward();
				position = player.eyes.position;
			}
			Vector3 val2 = ((Component)baseEntity).transform.position - position;
			float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
			bool num2 = num < AI.watchedAngle;
			if (num2)
			{
				timeNotWatched = 0f;
				timeWatched += deltaTime;
			}
			else
			{
				timeWatched = 0f;
				timeNotWatched += deltaTime;
			}
			if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
			{
				timeNotAimedAt = 0f;
				timeAimedAt += deltaTime;
			}
			else
			{
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
		else
		{
			timeVisible = 0f;
			timeNotVisible += deltaTime;
			timeWatched = 0f;
			timeNotWatched += deltaTime;
			timeAimedAt = 0f;
			timeNotAimedAt += deltaTime;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine.Assertions;

public class LockState
{
	public class LockHandle
	{
	}

	private HashSet<LockHandle> locks = new HashSet<LockHandle>();

	public bool IsLocked => locks.Count > 0;

	public LockHandle AddLock()
	{
		LockHandle lockHandle = Pool.Get<LockHandle>();
		locks.Add(lockHandle);
		return lockHandle;
	}

	public bool RemoveLock(ref LockHandle handle)
	{
		if (handle == null)
		{
			return false;
		}
		bool num = locks.Remove(handle);
		Assert.IsTrue(num, "Trying to remove a lock that doesn't exist");
		if (num)
		{
			Pool.FreeUnsafe<LockHandle>(ref handle);
		}
		return num;
	}
}


public class LockHandle
{
}


using UnityEngine;

public static class BaseEntityTargettingExtensions
{
	public static bool InSameNpcTeam(this BaseEntity entity, BaseEntity other)
	{
		if ((Object)(object)entity == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		return ((object)entity).GetType() == ((object)other).GetType();
	}

	public static bool IsNonNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return !basePlayer.IsNpc;
		}
		return false;
	}

	public static bool IsNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.IsNpc;
		}
		return false;
	}

	public static bool ToNonNpcPlayer(this BaseEntity entity, out BasePlayer player)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			player = null;
			return false;
		}
		player = basePlayer;
		return true;
	}
}


public static class PlayerMenuAnimation
{
	public enum Layers
	{
		Movement
	}

	public static class Groups
	{
	}
}


public enum Layers
{
	Movement
}


public static class Groups
{
}


using System;
using AntiHackJobs;
using BasePlayerJobs;
using CoarseQueryGridJobs;
using CompanionServer.Cameras;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using GamePhysicsJobs;
using GenerateErosionJobs;
using Instancing;
using Rust.Water5;
using TerrainHeightMapJobs;
using TerrainTexturingJobs;
using TerrainTopologyMapJobs;
using TerrainWaterMapJobs;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;
using WaterLevelJobs;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1221673671587648887
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionGatherJob>();
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionProcessJob>();
			IJobParallelForExtensions.EarlyJobInit<FishShoal.FishUpdateJob>();
			IJobExtensions.EarlyJobInit<FishShoal.KillFish>();
			IJobParallelForTransformExtensions.EarlyJobInit<TransformLineRenderer.LineRendererUpdateJob>();
			IJobExtensions.EarlyJobInit<AddAndBlurSphereJob>();
			IJobForExtensions.EarlyJobInit<BoxBlur3DJob>();
			IJobExtensions.EarlyJobInit<BoxBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<BoxBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CleanFloatingIslandsJob>();
			IJobParallelForExtensions.EarlyJobInit<Hopper.FillRaycastJob>();
			IJobExtensions.EarlyJobInit<CalculatePathBetweenGridsJob>();
			IJobExtensions.EarlyJobInit<PostCullingJob>();
			IJobExtensions.EarlyJobInit<GenerateAscSeqListJob>();
			IJobExtensions.EarlyJobInit<InvertIndexListJob>();
			IJobExtensions.EarlyJobInit<RaycastSamplePositionsJob>();
			IJobExtensions.EarlyJobInit<RaycastBufferSetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRaySetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRayProcessingJob>();
			IJobExtensions.EarlyJobInit<RaycastOutputCompressJob>();
			IJobExtensions.EarlyJobInit<RaycastColliderProcessingJob>();
			IJobExtensions.EarlyJobInit<GatherPlayersWithTicksJob>();
			IJobExtensions.EarlyJobInit<BuildLayerMasksJob>();
			IJobExtensions.EarlyJobInit<GatherHitIndicesJob>();
			IJobExtensions.EarlyJobInit<BuildBatchLookupMapJob>();
			IJobExtensions.EarlyJobInit<GatherNoClipBatchesJob>();
			IJobExtensions.EarlyJobInit<FindValidIndicesJob>();
			IJobExtensions.EarlyJobInit<PreCullingJob>();
			IJobForExtensions.EarlyJobInit<PaintSplatJob>();
			IJobParallelForExtensions.EarlyJobInit<PopulateDeltaHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<CopyBackFloatHeightToShortHeightJob>();
			IJobParallelForExtensions.EarlyJobInit<EvaporationJob>();
			IJobParallelForBatchExtensions.EarlyJobInit<PrepareMapJob>();
			IJobParallelForExtensions.EarlyJobInit<TransportSedimentJob>();
			IJobParallelForExtensions.EarlyJobInit<CalcMinHeightMapJob>();
			IJobParallelForExtensions.EarlyJobInit<ErosionAndDepositionJob>();
			IJobParallelForExtensions.EarlyJobInit<TileCalculateAngleMap>();
			IJobParallelForExtensions.EarlyJobInit<AdjustWaterHeightByFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<CalculateOutputFluxJob>();
			IJobParallelForExtensions.EarlyJobInit<RefillOceanJob>();
			IJobParallelForExtensions.EarlyJobInit<WaterIncrementationJob>();
			IJobExtensions.EarlyJobInit<GetCoarseDistsToShoreJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByPosJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByPosJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJob>();
			IJobExtensions.EarlyJobInit<GetTopologyRadiusJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsFastJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsJob>();
			IJobExtensions.EarlyJobInit<TerrainHeightMapJobs.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckPosRadJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckBoundsJob>();
			IJobExtensions.EarlyJobInit<CheckBoundsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckRayJob>();
			IJobExtensions.EarlyJobInit<ToUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherWavesIndicesJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyMaxHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SelectMaxWaterLevelJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcCenterJobIndirect>();
			IJobExtensions.EarlyJobInit<InitialValidateInfoJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherValidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherInvalidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SetupHeadQueryJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyHeadQueryResultsJobIndirect>();
			IJobExtensions.EarlyJobInit<ResolveWaterInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterCache>();
			IJobExtensions.EarlyJobInit<GatherPosToValidateJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<RecacheTransforms>();
			IJobExtensions.EarlyJobInit<CalcWaterFactorsJobIndirect>();
			IJobExtensions.EarlyJobInit<GetWaterFactorsParamsJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcMidpoingJob>();
			IJobExtensions.EarlyJobInit<CheckHitsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<FindSphereCmdsInCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateSphereCmdsFromCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<RemoveLayerMaskJob>();
			IJobExtensions.EarlyJobInit<CountRaycastHitsJobs>();
			IJobExtensions.EarlyJobInit<ScatterColliderHitsJob>();
			IJobExtensions.EarlyJobInit<CopyBackJob>();
			IJobExtensions.EarlyJobInit<PopulateArraysJob>();
			IJobExtensions.EarlyJobInit<SimplifyMeshJob>();
			IJobParallelForExtensions.EarlyJobInit<BakePhysicsMeshesJob>();
			IJobExtensions.EarlyJobInit<CleanupDuplicateVerticesJob>();
			IJobExtensions.EarlyJobInit<MarchJob>();
			IJobExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobExtensions.EarlyJobInit<Rust.Water5.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherJob<OverlapCapsuleCommand>>();
			IJobExtensions.EarlyJobInit<FillJob<float>>();
			IJobExtensions.EarlyJobInit<FillJob<int>>();
			IJobExtensions.EarlyJobInit<FillJob<bool>>();
			IJobExtensions.EarlyJobInit<GatherJob<Vector3>>();
			IJobExtensions.EarlyJobInit<GatherJob<float>>();
			IJobExtensions.EarlyJobInit<CopyArrayJob<float>>();
			IJobExtensions.EarlyJobInit<GatherJob<int>>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}



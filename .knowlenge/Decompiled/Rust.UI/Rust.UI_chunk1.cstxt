using Rust.UI;
using UnityEngine.Events;

public class RustButtonHover : RustButton
{
	public UnityEvent PointerEnter;

	public UnityEvent PointerExit;
}


using UnityEngine;
using UnityEngine.UI;

public class CoverImage : MaskableGraphic
{
	[SerializeField]
	private Texture _texture;

	public Texture texture
	{
		get
		{
			return _texture;
		}
		set
		{
			if (!((Object)(object)value == (Object)(object)texture))
			{
				_texture = value;
				((Graphic)this).SetVerticesDirty();
				((Graphic)this).SetMaterialDirty();
			}
		}
	}

	public override Texture mainTexture
	{
		get
		{
			if (!((Object)(object)_texture != (Object)null))
			{
				return (Texture)(object)Graphic.s_WhiteTexture;
			}
			return _texture;
		}
	}

	public CoverImage()
	{
		((Graphic)this).useLegacyMeshGeneration = false;
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_texture == (Object)null)
		{
			((Graphic)this).OnPopulateMesh(vh);
			return;
		}
		Rect dst = ((Graphic)this).GetPixelAdjustedRect();
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(((Rect)(ref dst)).x, ((Rect)(ref dst)).y, ((Rect)(ref dst)).x + ((Rect)(ref dst)).width, ((Rect)(ref dst)).y + ((Rect)(ref dst)).height);
		float num = (float)_texture.width * _texture.texelSize.x;
		float num2 = (float)_texture.height * _texture.texelSize.y;
		Color32 val2 = Color32.op_Implicit(((Graphic)this).color);
		Rect coverRect = GetCoverRect(in dst, _texture);
		vh.Clear();
		vh.AddVert(new Vector3(val.x, val.y), val2, new Vector2(((Rect)(ref coverRect)).xMin * num, ((Rect)(ref coverRect)).yMin * num2));
		vh.AddVert(new Vector3(val.x, val.w), val2, new Vector2(((Rect)(ref coverRect)).xMin * num, ((Rect)(ref coverRect)).yMax * num2));
		vh.AddVert(new Vector3(val.z, val.w), val2, new Vector2(((Rect)(ref coverRect)).xMax * num, ((Rect)(ref coverRect)).yMax * num2));
		vh.AddVert(new Vector3(val.z, val.y), val2, new Vector2(((Rect)(ref coverRect)).xMax * num, ((Rect)(ref coverRect)).yMin * num2));
		vh.AddTriangle(0, 1, 2);
		vh.AddTriangle(2, 3, 0);
	}

	private Rect GetCoverRect(in Rect dst, Texture texture)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		Rect result = dst;
		Vector2 size = ((Rect)(ref result)).size;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)texture.width, (float)texture.height);
		float num = size.x / size.y;
		float num2 = val.x / val.y;
		float num3 = ((num >= num2) ? (size.x / val.x) : (size.y / val.y));
		float num4 = val.x * num3;
		float num5 = val.y * num3;
		result = default(Rect);
		((Rect)(ref result)).x = (num4 - size.x) / 2f / num4;
		((Rect)(ref result)).y = (num5 - size.y) / 2f / num5;
		((Rect)(ref result)).width = size.x / num4;
		((Rect)(ref result)).height = size.y / num5;
		return result;
	}

	protected override void OnDidApplyAnimationProperties()
	{
		((Graphic)this).SetMaterialDirty();
		((Graphic)this).SetVerticesDirty();
	}

	protected override void OnRectTransformDimensionsChange()
	{
		((Graphic)this).SetVerticesDirty();
	}
}


using System;
using Facepunch;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

[RequireComponent(typeof(CoverImage), typeof(VideoPlayer))]
public class CoverVideo : MonoBehaviour
{
	public string Url;

	[Min(0f)]
	public float FadeIn = 0.5f;

	public Graphic Fallback;

	private CoverImage _cover;

	private VideoPlayer _player;

	private CanvasRenderer _fallbackGraphic;

	public void OnEnable()
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Expected O, but got Unknown
		_cover = ((Component)this).GetComponent<CoverImage>();
		_player = ((Component)this).GetComponent<VideoPlayer>();
		CanvasRenderer val = default(CanvasRenderer);
		if ((Object)(object)Fallback != (Object)null && ((Component)Fallback).TryGetComponent<CanvasRenderer>(ref val))
		{
			val.SetAlpha(1f);
		}
		CanvasRenderer val2 = default(CanvasRenderer);
		if (((Component)this).TryGetComponent<CanvasRenderer>(ref val2))
		{
			val2.SetAlpha(0f);
		}
		if ((Object)(object)_cover != (Object)null && (Object)(object)_player != (Object)null && !string.IsNullOrWhiteSpace(Url))
		{
			((Graphic)_cover).color = Color.white;
			_player.renderMode = (VideoRenderMode)4;
			_player.prepareCompleted += new EventHandler(PlayerPrepareCompleted);
			Play(Url);
		}
	}

	public void OnDisable()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Expected O, but got Unknown
		if ((Object)(object)_cover != (Object)null)
		{
			_cover.texture = null;
		}
		if ((Object)(object)_player != (Object)null)
		{
			_player.prepareCompleted -= new EventHandler(PlayerPrepareCompleted);
			_player.Stop();
		}
	}

	private async void Play(string url)
	{
		try
		{
			string text = await WebUtil.DownloadFileTemp(url, WebUtil.ValidVideoExtensions);
			if (!string.IsNullOrEmpty(text))
			{
				_player.Stop();
				_player.url = text;
				_player.Play();
			}
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)ex);
		}
	}

	private void PlayerPrepareCompleted(VideoPlayer source)
	{
		if (!((Object)(object)_cover == (Object)null) && !((Object)(object)_player == (Object)null))
		{
			_cover.texture = _player.texture;
			((Graphic)_cover).CrossFadeAlpha(1f, FadeIn, false);
			if ((Object)(object)Fallback != (Object)null)
			{
				Fallback.CrossFadeAlpha(0f, FadeIn, false);
			}
		}
	}
}


using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class HoverListener : MonoBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	public UnityEvent OnEnter;

	public UnityEvent OnExit;

	public void OnPointerEnter(PointerEventData eventData)
	{
		UnityEvent onEnter = OnEnter;
		if (onEnter != null)
		{
			onEnter.Invoke();
		}
	}

	public void OnPointerExit(PointerEventData eventData)
	{
		UnityEvent onExit = OnExit;
		if (onExit != null)
		{
			onExit.Invoke();
		}
	}
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

[ExecuteInEditMode]
public class CanvasLineRenderer : Graphic
{
	public List<Vector2> Points = new List<Vector2>();

	public float Thickness = 10f;

	public float CurveOffset = 10f;

	public int CornerTesselation = 3;

	public float DistanceUvMultiplier = 0.05f;

	public Texture RepeatTexture;

	public override Texture mainTexture
	{
		get
		{
			if (!((Object)(object)RepeatTexture == (Object)null))
			{
				return RepeatTexture;
			}
			return (Texture)(object)Graphic.s_WhiteTexture;
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class RustUiTest : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static UnityAction <>9__3_0;

		public static UnityAction <>9__3_1;

		public static UnityAction <>9__3_2;

		public static UnityAction<Option> <>9__3_3;

		public static UnityAction<string> <>9__3_4;

		public static UnityAction<float> <>9__3_5;

		public static UnityAction<float> <>9__3_6;

		public static UnityAction<bool> <>9__3_7;

		public static UnityAction<bool> <>9__3_8;

		public static UnityAction<bool> <>9__3_9;

		public static UnityAction<Option> <>9__3_11;

		public static UnityAction<Option> <>9__3_12;

		public static UnityAction<Option> <>9__3_13;

		internal void <Awake>b__3_0()
		{
			Debug.Log((object)"Button Pressed");
		}

		internal void <Awake>b__3_1()
		{
			Debug.Log((object)"Button Pressed");
		}

		internal void <Awake>b__3_2()
		{
			Debug.Log((object)"Button Pressed");
		}

		internal void <Awake>b__3_3(Option val)
		{
			Debug.Log((object)("Value Changed: " + val.Value));
		}

		internal void <Awake>b__3_4(string val)
		{
			Debug.Log((object)("Value Changed: " + val));
		}

		internal void <Awake>b__3_5(float val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_6(float val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_7(bool val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_8(bool val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_9(bool val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_11(Option val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_12(Option val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}

		internal void <Awake>b__3_13(Option val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		}
	}

	private static readonly Option[] enumOptions = new Option[3]
	{
		new Option("test.one", "Test One", "testone"),
		new Option("test.two", "Test Two", "testtwo"),
		new Option("test.three", "Test Three", "testthree")
	};

	private static readonly Option[] enumOptionsJustIcons = new Option[5]
	{
		new Option(Icons.Marker),
		new Option(Icons.Peace),
		new Option(Icons.Duck),
		new Option(Icons.MapPin),
		new Option(Icons.Fire)
	};

	private static readonly Option[] enumOptionsWithIcons = new Option[3]
	{
		new Option("test.one", "Test One", "testone", isdefault: false, Icons.UserNinja),
		new Option("test.two", "Test Two", "testtwo", isdefault: false, Icons.BookUser),
		new Option("test.three", "Test Three", "testthree")
	};

	private void Awake()
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Expected O, but got Unknown
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Expected O, but got Unknown
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Expected O, but got Unknown
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Expected O, but got Unknown
		//IL_0452: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Expected O, but got Unknown
		//IL_0478: Unknown result type (might be due to invalid IL or missing references)
		//IL_048e: Expected O, but got Unknown
		//IL_04a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Expected O, but got Unknown
		//IL_04d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Expected O, but got Unknown
		//IL_050c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0516: Expected O, but got Unknown
		TabControl tabControl = Make.Container.TabControl();
		((UIBehaviour)(object)tabControl).SetParent(((Component)this).transform);
		tabControl.AddTab("tabcontrol", Phrase.op_Implicit(string.Empty), Icons.Folders);
		TabControl tabControl2 = Make.Container.TabControl("Vertical");
		((UIBehaviour)(object)tabControl2).SetParent((UIBehaviour)(object)tabControl.Panel("tabcontrol"));
		tabControl2.AddTab("a", Phrase.op_Implicit(string.Empty), Icons.HandHeart);
		tabControl2.AddTab("b", Phrase.op_Implicit(string.Empty), Icons.OilCan);
		tabControl2.AddTab("c", Phrase.op_Implicit(string.Empty), Icons.SunCloud);
		tabControl.AddTab("buttons", Phrase.op_Implicit("Buttons"), Icons.Clipboard);
		RustButton rustButton = Make.Button(Phrase.op_Implicit("Button Normal"), Icons.Rss);
		((UIBehaviour)(object)rustButton).SetParent((UIBehaviour)(object)tabControl.Panel("buttons"));
		UnityEvent onPressed = rustButton.OnPressed;
		object obj = <>c.<>9__3_0;
		if (obj == null)
		{
			UnityAction val2 = delegate
			{
				Debug.Log((object)"Button Pressed");
			};
			<>c.<>9__3_0 = val2;
			obj = (object)val2;
		}
		onPressed.AddListener((UnityAction)obj);
		RustButton rustButton2 = Make.Button(Phrase.op_Implicit("Button Danger"), Icons.ExclamationTriangle, toggle: false, "Danger");
		((UIBehaviour)(object)rustButton2).SetParent((UIBehaviour)(object)tabControl.Panel("buttons"));
		UnityEvent onPressed2 = rustButton2.OnPressed;
		object obj2 = <>c.<>9__3_1;
		if (obj2 == null)
		{
			UnityAction val3 = delegate
			{
				Debug.Log((object)"Button Pressed");
			};
			<>c.<>9__3_1 = val3;
			obj2 = (object)val3;
		}
		onPressed2.AddListener((UnityAction)obj2);
		RustButton rustButton3 = Make.Button(Phrase.op_Implicit("Button Success"), Icons.InfoSquare, toggle: false, "Success");
		((UIBehaviour)(object)rustButton3).SetParent((UIBehaviour)(object)tabControl.Panel("buttons"));
		UnityEvent onPressed3 = rustButton3.OnPressed;
		object obj3 = <>c.<>9__3_2;
		if (obj3 == null)
		{
			UnityAction val4 = delegate
			{
				Debug.Log((object)"Button Pressed");
			};
			<>c.<>9__3_2 = val4;
			obj3 = (object)val4;
		}
		onPressed3.AddListener((UnityAction)obj3);
		tabControl.AddTab("input", Phrase.op_Implicit("Inputs"), Icons.Inbox);
		RustOption rustOption = Make.Option(enumOptions);
		((UIBehaviour)(object)rustOption).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<Option>)rustOption.OnChanged).AddListener((UnityAction<Option>)delegate(Option val)
		{
			Debug.Log((object)("Value Changed: " + val.Value));
		});
		RustInput rustInput = Make.Input(Phrase.op_Implicit("Enter Your Name"));
		((UIBehaviour)(object)rustInput).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<string>)rustInput.OnValueChanged).AddListener((UnityAction<string>)delegate(string val)
		{
			Debug.Log((object)("Value Changed: " + val));
		});
		RustSlider rustSlider = Make.Slider(0f, 1f, 0.3f);
		((UIBehaviour)(object)rustSlider).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<float>)rustSlider.OnChanged).AddListener((UnityAction<float>)delegate(float val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		RustSlider rustSlider2 = Make.Slider(0f, 50f, 3f, integer: true);
		((UIBehaviour)(object)rustSlider2).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<float>)rustSlider2.OnChanged).AddListener((UnityAction<float>)delegate(float val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		RustToggle rustToggle = Make.ToggleOnOff();
		((UIBehaviour)(object)rustToggle).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<bool>)rustToggle.OnChanged).AddListener((UnityAction<bool>)delegate(bool val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		RustToggle rustToggle2 = Make.ToggleEnabledDisabled();
		((UIBehaviour)(object)rustToggle2).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<bool>)rustToggle2.OnChanged).AddListener((UnityAction<bool>)delegate(bool val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		RustToggle rustToggle3 = Make.Toggle(Phrase.op_Implicit("Awake"), Phrase.op_Implicit("Asleep"));
		((UIBehaviour)(object)rustToggle3).SetParent((UIBehaviour)(object)tabControl.Panel("input"));
		((UnityEvent<bool>)rustToggle3.OnChanged).AddListener((UnityAction<bool>)delegate(bool val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		tabControl.AddTab("menu", Phrase.op_Implicit("Menu"), Icons.Backward);
		RustButton file = Make.Button(new Phrase("menu.file", "File"), Icons.File, toggle: true, "Toolbar.Normal", autoSize: true);
		RustWrapper rustWrapper = Make.Container.Toolbar();
		rustWrapper.Add((UIBehaviour)(object)file);
		rustWrapper.Add((UIBehaviour)(object)Make.Button(new Phrase("menu.edit", "Edit"), Icons.Pencil, toggle: true, "Toolbar.Normal", autoSize: true));
		rustWrapper.Add((UIBehaviour)(object)Make.Button(new Phrase("menu.view", "View"), Icons.Magnet, toggle: true, "Toolbar.Normal", autoSize: true));
		rustWrapper.AddFlex();
		rustWrapper.Add((UIBehaviour)(object)Make.Button(new Phrase("menu.exit", "Exit"), Icons.SearchMinus, toggle: true, "Toolbar.Normal", autoSize: true));
		((UIBehaviour)(object)rustWrapper).SetParent((UIBehaviour)(object)tabControl.Panel("menu"));
		RustButton rustButton4 = Make.Button(new Phrase("changebtext", "Change Button Text"), Icons.Sync);
		((UIBehaviour)(object)rustButton4).SetParent((UIBehaviour)(object)tabControl.Panel("menu"));
		rustButton4.OnPressed.AddListener((UnityAction)delegate
		{
			string[] array = new string[6] { "Hi", "Hello", "Long String", "File", "Buttes", "Yep" };
			file.Text.SetText(array[Random.Range(0, array.Length)]);
		});
		RustButtonGroup rustButtonGroup = Make.ButtonGroup(enumOptions);
		((UIBehaviour)(object)rustButtonGroup).SetParent((UIBehaviour)(object)tabControl.Panel("buttons"));
		((UnityEvent<Option>)rustButtonGroup.OnChanged).AddListener((UnityAction<Option>)delegate(Option val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		RustButtonGroup rustButtonGroup2 = Make.ButtonGroup(enumOptionsJustIcons);
		((UIBehaviour)(object)rustButtonGroup2).SetParent((UIBehaviour)(object)tabControl.Panel("buttons"));
		((UnityEvent<Option>)rustButtonGroup2.OnChanged).AddListener((UnityAction<Option>)delegate(Option val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
		RustButtonGroup rustButtonGroup3 = Make.ButtonGroup(enumOptionsWithIcons);
		((UIBehaviour)(object)rustButtonGroup3).SetParent((UIBehaviour)(object)tabControl.Panel("buttons"));
		((UnityEvent<Option>)rustButtonGroup3.OnChanged).AddListener((UnityAction<Option>)delegate(Option val)
		{
			Debug.Log((object)$"Value Changed: {val}");
		});
	}
}


public interface IAutoLayout
{
	void DoLayout();
}


using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Runtime.CompilerServices;

[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		MonoScriptData result = default(MonoScriptData);
		result.FilePathsData = new byte[2689]
		{
			0, 0, 0, 1, 0, 0, 0, 43, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 85,
			73, 92, 67, 111, 110, 116, 114, 111, 108, 115,
			92, 66, 108, 111, 99, 107, 101, 114, 46, 99,
			115, 0, 0, 0, 2, 0, 0, 0, 44, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			85, 73, 92, 67, 111, 110, 116, 114, 111, 108,
			115, 92, 68, 114, 111, 112, 100, 111, 119, 110,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			43, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 67, 111, 110, 116, 114,
			111, 108, 115, 92, 77, 97, 110, 97, 103, 101,
			114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
			0, 40, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 82, 117,
			115, 116, 46, 85, 73, 92, 67, 111, 110, 116,
			114, 111, 108, 115, 92, 77, 101, 110, 117, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 46,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 67, 111, 110, 116, 114, 111,
			108, 115, 92, 82, 117, 115, 116, 66, 117, 116,
			116, 111, 110, 46, 99, 115, 0, 0, 0, 2,
			0, 0, 0, 51, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 85, 73, 92, 67, 111,
			110, 116, 114, 111, 108, 115, 92, 82, 117, 115,
			116, 66, 117, 116, 116, 111, 110, 71, 114, 111,
			117, 112, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 51, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 85, 73, 92, 67, 111, 110,
			116, 114, 111, 108, 115, 92, 82, 117, 115, 116,
			66, 117, 116, 116, 111, 110, 72, 111, 118, 101,
			114, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 47, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 82, 117,
			115, 116, 46, 85, 73, 92, 67, 111, 110, 116,
			114, 111, 108, 115, 92, 82, 117, 115, 116, 67,
			111, 110, 116, 114, 111, 108, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 48, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 82, 117, 115, 116, 46, 85, 73,
			92, 67, 111, 110, 116, 114, 111, 108, 115, 92,
			82, 117, 115, 116, 70, 108, 101, 120, 84, 101,
			120, 116, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 44, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 85, 73, 92, 67, 111, 110,
			116, 114, 111, 108, 115, 92, 82, 117, 115, 116,
			73, 99, 111, 110, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 51, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 82, 117, 115, 116, 46, 85, 73, 92, 67,
			111, 110, 116, 114, 111, 108, 115, 92, 82, 117,
			115, 116, 73, 109, 97, 103, 101, 66, 117, 116,
			116, 111, 110, 46, 99, 115, 0, 0, 0, 2,
			0, 0, 0, 45, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 85, 73, 92, 67, 111,
			110, 116, 114, 111, 108, 115, 92, 82, 117, 115,
			116, 73, 110, 112, 117, 116, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 46, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 82, 117, 115, 116, 46, 85, 73,
			92, 67, 111, 110, 116, 114, 111, 108, 115, 92,
			82, 117, 115, 116, 76, 97, 121, 111, 117, 116,
			46, 99, 115, 0, 0, 0, 4, 0, 0, 0,
			46, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 67, 111, 110, 116, 114,
			111, 108, 115, 92, 82, 117, 115, 116, 79, 112,
			116, 105, 111, 110, 46, 99, 115, 0, 0, 0,
			2, 0, 0, 0, 46, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 82, 117, 115, 116, 46, 85, 73, 92, 67,
			111, 110, 116, 114, 111, 108, 115, 92, 82, 117,
			115, 116, 83, 108, 105, 100, 101, 114, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 46, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			85, 73, 92, 67, 111, 110, 116, 114, 111, 108,
			115, 92, 82, 117, 115, 116, 83, 116, 121, 108,
			101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 44, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 85, 73, 92, 67, 111, 110,
			116, 114, 111, 108, 115, 92, 82, 117, 115, 116,
			84, 101, 120, 116, 46, 99, 115, 0, 0, 0,
			2, 0, 0, 0, 46, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 82, 117, 115, 116, 46, 85, 73, 92, 67,
			111, 110, 116, 114, 111, 108, 115, 92, 82, 117,
			115, 116, 84, 111, 103, 103, 108, 101, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 47, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			85, 73, 92, 67, 111, 110, 116, 114, 111, 108,
			115, 92, 82, 117, 115, 116, 87, 114, 97, 112,
			112, 101, 114, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 46, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 85, 73, 92, 67, 111,
			110, 116, 114, 111, 108, 115, 92, 84, 97, 98,
			67, 111, 110, 116, 114, 111, 108, 46, 99, 115,
			0, 0, 0, 2, 0, 0, 0, 44, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 85,
			73, 92, 67, 111, 110, 116, 114, 111, 108, 115,
			92, 84, 105, 109, 101, 108, 105, 110, 101, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 50,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 67, 111, 110, 116, 114, 111,
			108, 115, 92, 84, 105, 109, 101, 108, 105, 110,
			101, 77, 97, 114, 107, 101, 114, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 45, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 85,
			73, 92, 67, 111, 110, 116, 114, 111, 108, 115,
			92, 84, 105, 109, 101, 82, 117, 108, 101, 114,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			41, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 67, 111, 110, 116, 114,
			111, 108, 115, 92, 86, 105, 100, 101, 111, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 37,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 67, 111, 118, 101, 114, 73,
			109, 97, 103, 101, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 37, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 82, 117, 115, 116, 46, 85, 73, 92, 67,
			111, 118, 101, 114, 86, 105, 100, 101, 111, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 50,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 68, 101, 98, 117, 103, 92,
			78, 101, 116, 71, 114, 97, 112, 104, 92, 78,
			101, 116, 71, 114, 97, 112, 104, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 54, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 85,
			73, 92, 68, 101, 98, 117, 103, 92, 78, 101,
			116, 71, 114, 97, 112, 104, 92, 78, 101, 116,
			71, 114, 97, 112, 104, 73, 116, 101, 109, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 53,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 68, 101, 98, 117, 103, 92,
			78, 101, 116, 71, 114, 97, 112, 104, 92, 78,
			101, 116, 71, 114, 97, 112, 104, 82, 111, 119,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			40, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 72, 111, 118, 101, 114,
			76, 105, 115, 116, 101, 110, 101, 114, 46, 99,
			115, 0, 0, 0, 1, 0, 0, 0, 36, 92,
			65, 115, 115, 101, 116, 115, 92, 80, 108, 117,
			103, 105, 110, 115, 92, 82, 117, 115, 116, 46,
			85, 73, 92, 72, 116, 116, 112, 73, 109, 97,
			103, 101, 46, 99, 115, 0, 0, 0, 1, 0,
			0, 0, 37, 92, 65, 115, 115, 101, 116, 115,
			92, 80, 108, 117, 103, 105, 110, 115, 92, 82,
			117, 115, 116, 46, 85, 73, 92, 76, 111, 97,
			100, 105, 110, 103, 66, 97, 114, 46, 99, 115,
			0, 0, 0, 2, 0, 0, 0, 41, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 85,
			73, 92, 77, 97, 107, 101, 46, 67, 111, 110,
			116, 97, 105, 110, 101, 114, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 31, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 82, 117, 115, 116, 46, 85, 73,
			92, 77, 97, 107, 101, 46, 99, 115, 0, 0,
			0, 2, 0, 0, 0, 36, 92, 65, 115, 115,
			101, 116, 115, 92, 80, 108, 117, 103, 105, 110,
			115, 92, 82, 117, 115, 116, 46, 85, 73, 92,
			77, 97, 107, 101, 46, 70, 111, 114, 109, 46,
			99, 115, 0, 0, 0, 2, 0, 0, 0, 37,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 77, 97, 107, 101, 46, 76,
			97, 98, 101, 108, 46, 99, 115, 0, 0, 0,
			1, 0, 0, 0, 58, 92, 65, 115, 115, 101,
			116, 115, 92, 80, 108, 117, 103, 105, 110, 115,
			92, 82, 117, 115, 116, 46, 85, 73, 92, 80,
			114, 111, 112, 101, 114, 116, 105, 101, 115, 92,
			66, 117, 116, 116, 111, 110, 71, 114, 111, 117,
			112, 65, 116, 116, 114, 105, 98, 117, 116, 101,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			52, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 80, 114, 111, 112, 101,
			114, 116, 105, 101, 115, 92, 76, 97, 98, 101,
			108, 65, 116, 116, 114, 105, 98, 117, 116, 101,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			48, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 80, 114, 111, 112, 101,
			114, 116, 105, 101, 115, 92, 80, 114, 111, 112,
			101, 114, 116, 105, 101, 115, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 55, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 82, 117, 115, 116, 46, 85, 73,
			92, 82, 101, 110, 100, 101, 114, 101, 114, 115,
			92, 67, 97, 110, 118, 97, 115, 76, 105, 110,
			101, 82, 101, 110, 100, 101, 114, 101, 114, 46,
			99, 115, 0, 0, 0, 2, 0, 0, 0, 49,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 82, 101, 110, 100, 101, 114,
			101, 114, 115, 92, 84, 105, 99, 107, 82, 101,
			110, 100, 101, 114, 101, 114, 46, 99, 115, 0,
			0, 0, 1, 0, 0, 0, 37, 92, 65, 115,
			115, 101, 116, 115, 92, 80, 108, 117, 103, 105,
			110, 115, 92, 82, 117, 115, 116, 46, 85, 73,
			92, 82, 117, 115, 116, 85, 105, 84, 101, 115,
			116, 46, 99, 115, 0, 0, 0, 4, 0, 0,
			0, 44, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 82, 117,
			115, 116, 46, 85, 73, 92, 83, 116, 121, 108,
			101, 115, 92, 83, 116, 121, 108, 101, 65, 115,
			115, 101, 116, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 39, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 85, 73, 92, 83, 117,
			112, 112, 114, 101, 115, 115, 77, 101, 110, 117,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			59, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 84, 104, 105, 114, 100,
			80, 97, 114, 116, 121, 92, 70, 105, 108, 101,
			68, 105, 97, 108, 111, 103, 92, 70, 105, 108,
			101, 68, 105, 97, 108, 111, 103, 46, 99, 115,
			0, 0, 0, 1, 0, 0, 0, 64, 92, 65,
			115, 115, 101, 116, 115, 92, 80, 108, 117, 103,
			105, 110, 115, 92, 82, 117, 115, 116, 46, 85,
			73, 92, 84, 104, 105, 114, 100, 80, 97, 114,
			116, 121, 92, 70, 105, 108, 101, 68, 105, 97,
			108, 111, 103, 92, 70, 105, 108, 101, 76, 105,
			115, 116, 69, 108, 101, 109, 101, 110, 116, 46,
			99, 115, 0, 0, 0, 1, 0, 0, 0, 46,
			92, 65, 115, 115, 101, 116, 115, 92, 80, 108,
			117, 103, 105, 110, 115, 92, 82, 117, 115, 116,
			46, 85, 73, 92, 85, 116, 105, 108, 105, 116,
			121, 92, 73, 65, 117, 116, 111, 76, 97, 121,
			111, 117, 116, 46, 99, 115, 0, 0, 0, 1,
			0, 0, 0, 50, 92, 65, 115, 115, 101, 116,
			115, 92, 80, 108, 117, 103, 105, 110, 115, 92,
			82, 117, 115, 116, 46, 85, 73, 92, 85, 116,
			105, 108, 105, 116, 121, 92, 82, 101, 99, 116,
			84, 114, 97, 110, 115, 102, 111, 114, 109, 69,
			120, 46, 99, 115, 0, 0, 0, 1, 0, 0,
			0, 51, 92, 65, 115, 115, 101, 116, 115, 92,
			80, 108, 117, 103, 105, 110, 115, 92, 82, 117,
			115, 116, 46, 85, 73, 92, 85, 116, 105, 108,
			105, 116, 121, 92, 84, 111, 103, 103, 108, 101,
			71, 97, 109, 101, 79, 98, 106, 101, 99, 116,
			46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
			48, 92, 65, 115, 115, 101, 116, 115, 92, 80,
			108, 117, 103, 105, 110, 115, 92, 82, 117, 115,
			116, 46, 85, 73, 92, 85, 116, 105, 108, 105,
			116, 121, 92, 85, 73, 66, 101, 104, 97, 118,
			105, 111, 117, 114, 69, 120, 46, 99, 115
		};
		result.TypesData = new byte[1707]
		{
			0, 0, 0, 0, 15, 82, 117, 115, 116, 46,
			85, 73, 124, 66, 108, 111, 99, 107, 101, 114,
			0, 0, 0, 0, 16, 82, 117, 115, 116, 46,
			85, 73, 124, 68, 114, 111, 112, 100, 111, 119,
			110, 0, 0, 0, 0, 29, 82, 117, 115, 116,
			46, 85, 73, 46, 68, 114, 111, 112, 100, 111,
			119, 110, 124, 67, 104, 97, 110, 103, 101, 100,
			69, 118, 101, 110, 116, 0, 0, 0, 0, 15,
			82, 117, 115, 116, 46, 85, 73, 124, 77, 97,
			110, 97, 103, 101, 114, 0, 0, 0, 0, 12,
			82, 117, 115, 116, 46, 85, 73, 124, 77, 101,
			110, 117, 0, 0, 0, 0, 25, 82, 117, 115,
			116, 46, 85, 73, 46, 77, 101, 110, 117, 124,
			67, 104, 97, 110, 103, 101, 100, 69, 118, 101,
			110, 116, 0, 0, 0, 0, 18, 82, 117, 115,
			116, 46, 85, 73, 124, 82, 117, 115, 116, 66,
			117, 116, 116, 111, 110, 0, 0, 0, 0, 23,
			82, 117, 115, 116, 46, 85, 73, 124, 82, 117,
			115, 116, 66, 117, 116, 116, 111, 110, 71, 114,
			111, 117, 112, 0, 0, 0, 0, 36, 82, 117,
			115, 116, 46, 85, 73, 46, 82, 117, 115, 116,
			66, 117, 116, 116, 111, 110, 71, 114, 111, 117,
			112, 124, 67, 104, 97, 110, 103, 101, 100, 69,
			118, 101, 110, 116, 0, 0, 0, 0, 16, 124,
			82, 117, 115, 116, 66, 117, 116, 116, 111, 110,
			72, 111, 118, 101, 114, 0, 0, 0, 0, 19,
			82, 117, 115, 116, 46, 85, 73, 124, 82, 117,
			115, 116, 67, 111, 110, 116, 114, 111, 108, 0,
			0, 0, 0, 20, 82, 117, 115, 116, 46, 85,
			73, 124, 82, 117, 115, 116, 70, 108, 101, 120,
			84, 101, 120, 116, 0, 0, 0, 0, 16, 82,
			117, 115, 116, 46, 85, 73, 124, 82, 117, 115,
			116, 73, 99, 111, 110, 0, 0, 0, 0, 23,
			82, 117, 115, 116, 46, 85, 73, 124, 82, 117,
			115, 116, 73, 109, 97, 103, 101, 66, 117, 116,
			116, 111, 110, 0, 0, 0, 0, 17, 82, 117,
			115, 116, 46, 85, 73, 124, 82, 117, 115, 116,
			73, 110, 112, 117, 116, 0, 0, 0, 0, 30,
			82, 117, 115, 116, 46, 85, 73, 46, 82, 117,
			115, 116, 73, 110, 112, 117, 116, 124, 67, 104,
			97, 110, 103, 101, 100, 69, 118, 101, 110, 116,
			0, 0, 0, 0, 18, 82, 117, 115, 116, 46,
			85, 73, 124, 82, 117, 115, 116, 76, 97, 121,
			111, 117, 116, 0, 0, 0, 0, 18, 82, 117,
			115, 116, 46, 85, 73, 124, 82, 117, 115, 116,
			79, 112, 116, 105, 111, 110, 0, 0, 0, 0,
			31, 82, 117, 115, 116, 46, 85, 73, 46, 82,
			117, 115, 116, 79, 112, 116, 105, 111, 110, 124,
			67, 104, 97, 110, 103, 101, 100, 69, 118, 101,
			110, 116, 0, 0, 0, 0, 14, 82, 117, 115,
			116, 46, 85, 73, 124, 79, 112, 116, 105, 111,
			110, 0, 0, 0, 0, 23, 82, 117, 115, 116,
			46, 85, 73, 124, 79, 112, 116, 105, 111, 110,
			65, 116, 116, 114, 105, 98, 117, 116, 101, 0,
			0, 0, 0, 18, 82, 117, 115, 116, 46, 85,
			73, 124, 82, 117, 115, 116, 83, 108, 105, 100,
			101, 114, 0, 0, 0, 0, 31, 82, 117, 115,
			116, 46, 85, 73, 46, 82, 117, 115, 116, 83,
			108, 105, 100, 101, 114, 124, 67, 104, 97, 110,
			103, 101, 100, 69, 118, 101, 110, 116, 0, 0,
			0, 0, 18, 82, 117, 115, 116, 46, 85, 73,
			124, 82, 117, 115, 116, 83, 116, 121, 108, 101,
			114, 0, 0, 0, 0, 16, 82, 117, 115, 116,
			46, 85, 73, 124, 82, 117, 115, 116, 84, 101,
			120, 116, 0, 0, 0, 0, 18, 82, 117, 115,
			116, 46, 85, 73, 124, 82, 117, 115, 116, 84,
			111, 103, 103, 108, 101, 0, 0, 0, 0, 31,
			82, 117, 115, 116, 46, 85, 73, 46, 82, 117,
			115, 116, 84, 111, 103, 103, 108, 101, 124, 67,
			104, 97, 110, 103, 101, 100, 69, 118, 101, 110,
			116, 0, 0, 0, 0, 19, 82, 117, 115, 116,
			46, 85, 73, 124, 82, 117, 115, 116, 87, 114,
			97, 112, 112, 101, 114, 0, 0, 0, 0, 18,
			82, 117, 115, 116, 46, 85, 73, 124, 84, 97,
			98, 67, 111, 110, 116, 114, 111, 108, 0, 0,
			0, 0, 16, 82, 117, 115, 116, 46, 85, 73,
			124, 84, 105, 109, 101, 108, 105, 110, 101, 0,
			0, 0, 0, 27, 82, 117, 115, 116, 46, 85,
			73, 46, 84, 105, 109, 101, 108, 105, 110, 101,
			124, 83, 99, 114, 117, 98, 69, 118, 101, 110,
			116, 0, 0, 0, 0, 22, 82, 117, 115, 116,
			46, 85, 73, 124, 84, 105, 109, 101, 108, 105,
			110, 101, 77, 97, 114, 107, 101, 114, 0, 0,
			0, 0, 17, 82, 117, 115, 116, 46, 85, 73,
			124, 84, 105, 109, 101, 82, 117, 108, 101, 114,
			0, 0, 0, 0, 13, 82, 117, 115, 116, 46,
			85, 73, 124, 86, 105, 100, 101, 111, 0, 0,
			0, 0, 11, 124, 67, 111, 118, 101, 114, 73,
			109, 97, 103, 101, 0, 0, 0, 0, 11, 124,
			67, 111, 118, 101, 114, 86, 105, 100, 101, 111,
			0, 0, 0, 0, 26, 82, 117, 115, 116, 46,
			85, 73, 46, 68, 101, 98, 117, 103, 103, 105,
			110, 103, 124, 78, 101, 116, 71, 114, 97, 112,
			104, 0, 0, 0, 0, 30, 82, 117, 115, 116,
			46, 85, 73, 46, 68, 101, 98, 117, 103, 103,
			105, 110, 103, 124, 78, 101, 116, 71, 114, 97,
			112, 104, 73, 116, 101, 109, 0, 0, 0, 0,
			29, 82, 117, 115, 116, 46, 85, 73, 46, 68,
			101, 98, 117, 103, 103, 105, 110, 103, 124, 78,
			101, 116, 71, 114, 97, 112, 104, 82, 111, 119,
			0, 0, 0, 0, 14, 124, 72, 111, 118, 101,
			114, 76, 105, 115, 116, 101, 110, 101, 114, 0,
			0, 0, 0, 17, 82, 117, 115, 116, 46, 85,
			73, 124, 72, 116, 116, 112, 73, 109, 97, 103,
			101, 0, 0, 0, 0, 18, 82, 117, 115, 116,
			46, 85, 73, 124, 76, 111, 97, 100, 105, 110,
			103, 66, 97, 114, 1, 0, 0, 0, 12, 82,
			117, 115, 116, 46, 85, 73, 124, 77, 97, 107,
			101, 0, 0, 0, 0, 22, 82, 117, 115, 116,
			46, 85, 73, 46, 77, 97, 107, 101, 124, 67,
			111, 110, 116, 97, 105, 110, 101, 114, 1, 0,
			0, 0, 12, 82, 117, 115, 116, 46, 85, 73,
			124, 77, 97, 107, 101, 1, 0, 0, 0, 12,
			82, 117, 115, 116, 46, 85, 73, 124, 77, 97,
			107, 101, 0, 0, 0, 0, 17, 82, 117, 115,
			116, 46, 85, 73, 46, 77, 97, 107, 101, 124,
			70, 111, 114, 109, 1, 0, 0, 0, 12, 82,
			117, 115, 116, 46, 85, 73, 124, 77, 97, 107,
			101, 0, 0, 0, 0, 18, 82, 117, 115, 116,
			46, 85, 73, 46, 77, 97, 107, 101, 124, 76,
			97, 98, 101, 108, 0, 0, 0, 0, 28, 82,
			117, 115, 116, 46, 85, 73, 124, 66, 117, 116,
			116, 111, 110, 71, 114, 111, 117, 112, 65, 116,
			116, 114, 105, 98, 117, 116, 101, 0, 0, 0,
			0, 22, 82, 117, 115, 116, 46, 85, 73, 124,
			76, 97, 98, 101, 108, 65, 116, 116, 114, 105,
			98, 117, 116, 101, 0, 0, 0, 0, 18, 82,
			117, 115, 116, 46, 85, 73, 124, 80, 114, 111,
			112, 101, 114, 116, 105, 101, 115, 0, 0, 0,
			0, 19, 124, 67, 97, 110, 118, 97, 115, 76,
			105, 110, 101, 82, 101, 110, 100, 101, 114, 101,
			114, 0, 0, 0, 0, 29, 82, 117, 115, 116,
			46, 85, 73, 46, 82, 101, 110, 100, 101, 114,
			101, 114, 124, 84, 105, 99, 107, 82, 101, 110,
			100, 101, 114, 101, 114, 0, 0, 0, 0, 34,
			82, 117, 115, 116, 46, 85, 73, 46, 82, 101,
			110, 100, 101, 114, 101, 114, 46, 84, 105, 99,
			107, 82, 101, 110, 100, 101, 114, 101, 114, 124,
			84, 105, 99, 107, 0, 0, 0, 0, 11, 124,
			82, 117, 115, 116, 85, 105, 84, 101, 115, 116,
			0, 0, 0, 0, 18, 82, 117, 115, 116, 46,
			85, 73, 124, 83, 116, 121, 108, 101, 65, 115,
			115, 101, 116, 0, 0, 0, 0, 24, 82, 117,
			115, 116, 46, 85, 73, 46, 83, 116, 121, 108,
			101, 65, 115, 115, 101, 116, 124, 71, 114, 111,
			117, 112, 0, 0, 0, 0, 32, 82, 117, 115,
			116, 46, 85, 73, 46, 83, 116, 121, 108, 101,
			65, 115, 115, 101, 116, 124, 79, 118, 101, 114,
			114, 105, 100, 101, 71, 114, 111, 117, 112, 0,
			0, 0, 0, 21, 82, 117, 115, 116, 46, 85,
			73, 124, 83, 116, 121, 108, 101, 67, 111, 108,
			111, 114, 83, 101, 116, 0, 0, 0, 0, 20,
			82, 117, 115, 116, 46, 85, 73, 124, 83, 117,
			112, 112, 114, 101, 115, 115, 77, 101, 110, 117,
			0, 0, 0, 0, 18, 82, 117, 115, 116, 46,
			85, 73, 124, 70, 105, 108, 101, 68, 105, 97,
			108, 111, 103, 0, 0, 0, 0, 23, 82, 117,
			115, 116, 46, 85, 73, 124, 70, 105, 108, 101,
			76, 105, 115, 116, 69, 108, 101, 109, 101, 110,
			116, 0, 0, 0, 0, 12, 124, 73, 65, 117,
			116, 111, 76, 97, 121, 111, 117, 116, 0, 0,
			0, 0, 27, 85, 110, 105, 116, 121, 69, 110,
			103, 105, 110, 101, 124, 82, 101, 99, 116, 84,
			114, 97, 110, 115, 102, 111, 114, 109, 69, 120,
			0, 0, 0, 0, 32, 82, 117, 115, 116, 46,
			85, 73, 46, 85, 116, 105, 108, 105, 116, 121,
			124, 84, 111, 103, 103, 108, 101, 71, 97, 109,
			101, 79, 98, 106, 101, 99, 116, 0, 0, 0,
			0, 25, 85, 110, 105, 116, 121, 69, 110, 103,
			105, 110, 101, 124, 85, 73, 66, 101, 104, 97,
			118, 105, 111, 117, 114, 69, 120
		};
		result.TotalFiles = 50;
		result.TotalTypes = 67;
		result.IsEditorOnly = false;
		return result;
	}
}


using UnityEngine;

public static class RectTransformEx
{
	public static void AnchorToCorners(this RectTransform transform)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)((Transform)transform).parent == (Object)null))
		{
			Transform parent = ((Transform)transform).parent;
			RectTransform val = (RectTransform)(object)((parent is RectTransform) ? parent : null);
			float x = transform.anchorMin.x;
			float x2 = transform.offsetMin.x;
			Rect rect = val.rect;
			float num = x + x2 / ((Rect)(ref rect)).width;
			float y = transform.anchorMin.y;
			float y2 = transform.offsetMin.y;
			rect = val.rect;
			Vector2 anchorMin = default(Vector2);
			((Vector2)(ref anchorMin))..ctor(num, y + y2 / ((Rect)(ref rect)).height);
			float x3 = transform.anchorMax.x;
			float x4 = transform.offsetMax.x;
			rect = val.rect;
			float num2 = x3 + x4 / ((Rect)(ref rect)).width;
			float y3 = transform.anchorMax.y;
			float y4 = transform.offsetMax.y;
			rect = val.rect;
			Vector2 anchorMax = default(Vector2);
			((Vector2)(ref anchorMax))..ctor(num2, y3 + y4 / ((Rect)(ref rect)).height);
			transform.anchorMin = anchorMin;
			transform.anchorMax = anchorMax;
			Vector2 val2 = default(Vector2);
			((Vector2)(ref val2))..ctor(0f, 0f);
			transform.offsetMax = val2;
			transform.offsetMin = val2;
		}
	}

	public static void Fill(this RectTransform tx, float l = 0f, float t = 0f, float r = 0f, float b = 0f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		tx.anchorMin = Vector2.zero;
		tx.anchorMax = Vector2.one;
		tx.anchoredPosition = Vector2.zero;
		tx.pivot = Vector2.one * 0.5f;
		tx.offsetMin = new Vector2(l, b);
		tx.offsetMax = new Vector2(0f - t, 0f - r);
	}

	public static void AnchorTopRight(this RectTransform tx)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		tx.SetPivotAndAnchors(new Vector2(1f, 1f));
	}

	public static RectTransform AlignRight(this RectTransform tx, float offset = 0f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		tx.pivot = Vector2Ex.WithX(tx.pivot, 1f);
		tx.anchorMin = Vector2Ex.WithX(tx.anchorMin, 1f);
		tx.anchorMax = Vector2Ex.WithX(tx.anchorMax, 1f);
		tx.anchoredPosition = Vector2Ex.WithX(tx.anchoredPosition, offset);
		return tx;
	}

	public static RectTransform AlignLeft(this RectTransform tx, float offset = 0f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		tx.pivot = Vector2Ex.WithX(tx.pivot, 0f);
		tx.anchorMin = Vector2Ex.WithX(tx.anchorMin, 0f);
		tx.anchorMax = Vector2Ex.WithX(tx.anchorMax, 0f);
		tx.anchoredPosition = Vector2Ex.WithX(tx.anchoredPosition, offset);
		return tx;
	}

	public static RectTransform AlignTop(this RectTransform tx, float offset = 0f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		tx.pivot = Vector2Ex.WithY(tx.pivot, 1f);
		tx.anchorMin = Vector2Ex.WithY(tx.anchorMin, 1f);
		tx.anchorMax = Vector2Ex.WithY(tx.anchorMax, 1f);
		tx.anchoredPosition = Vector2Ex.WithY(tx.anchoredPosition, 0f - offset);
		return tx;
	}

	public static Rect GetScreenRect(this RectTransform transform)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return RectTransformUtility.PixelAdjustRect(transform, ((Component)transform).GetComponentInParent<Canvas>());
	}

	public static void SetPivotAndAnchors(this RectTransform trans, Vector2 aVec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		trans.pivot = aVec;
		trans.anchorMin = aVec;
		trans.anchorMax = aVec;
	}

	public static Vector2 GetSize(this RectTransform trans)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = trans.rect;
		return ((Rect)(ref rect)).size;
	}

	public static float GetWidth(this RectTransform trans)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = trans.rect;
		return ((Rect)(ref rect)).width;
	}

	public static float GetHeight(this RectTransform trans)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = trans.rect;
		return ((Rect)(ref rect)).height;
	}

	public static bool SetSize(this RectTransform trans, Vector2 newSize)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = trans.rect;
		Vector2 size = ((Rect)(ref rect)).size;
		Vector2 val = newSize - size;
		Vector2 val2 = trans.offsetMin - new Vector2(val.x * trans.pivot.x, val.y * trans.pivot.y);
		Vector2 val3 = trans.offsetMax + new Vector2(val.x * (1f - trans.pivot.x), val.y * (1f - trans.pivot.y));
		if (val3 == trans.offsetMax && val2 == trans.offsetMin)
		{
			return false;
		}
		trans.offsetMin = val2;
		trans.offsetMax = val3;
		return true;
	}

	public static bool SetWidth(this RectTransform trans, float newSize)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = trans.rect;
		return trans.SetSize(new Vector2(newSize, ((Rect)(ref rect)).size.y));
	}

	public static void MoveY(this RectTransform trans, float amount)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		trans.Move(new Vector2(0f, amount));
	}

	public static void Move(this RectTransform trans, Vector2 move)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		trans.offsetMin += move;
		trans.offsetMax += move;
	}

	public static bool SetHeight(this RectTransform trans, float newSize)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = trans.rect;
		return trans.SetSize(new Vector2(((Rect)(ref rect)).size.x, newSize));
	}

	public static void SetBottomLeftPosition(this RectTransform trans, Vector2 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		float x = newPos.x;
		float x2 = trans.pivot.x;
		Rect rect = trans.rect;
		float num = x + x2 * ((Rect)(ref rect)).width;
		float y = newPos.y;
		float y2 = trans.pivot.y;
		rect = trans.rect;
		((Transform)trans).localPosition = new Vector3(num, y + y2 * ((Rect)(ref rect)).height, ((Transform)trans).localPosition.z);
	}

	public static void SetTopLeftPosition(this RectTransform trans, Vector2 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float x = newPos.x;
		float x2 = trans.pivot.x;
		Rect rect = trans.rect;
		float num = x + x2 * ((Rect)(ref rect)).width;
		float y = newPos.y;
		float num2 = 1f - trans.pivot.y;
		rect = trans.rect;
		((Transform)trans).localPosition = new Vector3(num, y - num2 * ((Rect)(ref rect)).height, ((Transform)trans).localPosition.z);
	}

	public static void SetBottomRightPosition(this RectTransform trans, Vector2 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float x = newPos.x;
		float num = 1f - trans.pivot.x;
		Rect rect = trans.rect;
		float num2 = x - num * ((Rect)(ref rect)).width;
		float y = newPos.y;
		float y2 = trans.pivot.y;
		rect = trans.rect;
		((Transform)trans).localPosition = new Vector3(num2, y + y2 * ((Rect)(ref rect)).height, ((Transform)trans).localPosition.z);
	}

	public static void SetRightTopPosition(this RectTransform trans, Vector2 newPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		float x = newPos.x;
		float num = 1f - trans.pivot.x;
		Rect rect = trans.rect;
		float num2 = x - num * ((Rect)(ref rect)).width;
		float y = newPos.y;
		float num3 = 1f - trans.pivot.y;
		rect = trans.rect;
		((Transform)trans).localPosition = new Vector3(num2, y - num3 * ((Rect)(ref rect)).height, ((Transform)trans).localPosition.z);
	}

	public static void DoAutoLayout(this RectTransform trans)
	{
		IAutoLayout autoLayout = default(IAutoLayout);
		while ((Object)(object)trans != (Object)null)
		{
			if (((Component)trans).TryGetComponent<IAutoLayout>(ref autoLayout))
			{
				autoLayout.DoLayout();
			}
			Transform parent = ((Transform)trans).parent;
			trans = (RectTransform)(object)((parent is RectTransform) ? parent : null);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;

public static class UIBehaviourEx
{
	public static void SetParent(this UIBehaviour self, Transform parent)
	{
		((Component)self).transform.SetParent(parent, false);
		if (!((Component)parent).gameObject.activeInHierarchy)
		{
			((Component)parent).GetComponent<RustLayout>()?.DoLayout();
		}
	}

	public static void SetParent(this UIBehaviour self, Canvas parent)
	{
		self.SetParent(((Component)parent).transform);
	}

	public static void SetParent(this UIBehaviour self, UIBehaviour parent)
	{
		self.SetParent(((Component)parent).transform);
	}

	public static void SetParentRootCanvas(this UIBehaviour self, Transform tx)
	{
		Canvas componentInParent = ((Component)tx).GetComponentInParent<Canvas>();
		if (!((Object)(object)componentInParent == (Object)null))
		{
			componentInParent = componentInParent.rootCanvas;
			self.SetParent(componentInParent);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;

public class Blocker : RustControl, IPointerDownHandler, IEventSystemHandler
{
	public void OnPointerDown(PointerEventData eventData)
	{
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}

	public void AddToCanvasOf(RectTransform rt)
	{
		Canvas componentInParent = ((Component)rt).GetComponentInParent<Canvas>();
		((UIBehaviour)(object)this).SetParent(componentInParent);
		base.rectTransform.Fill(-10f, -10f, -10f, -10f);
	}
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class Dropdown : RustControl, IPointerDownHandler, IEventSystemHandler
{
	[Serializable]
	public class ChangedEvent : UnityEvent<Option>
	{
	}

	public RustIcon Icon;

	public RustText Text;

	public RustIcon OptionIcon;

	public Option[] Options;

	private int CurrentOption;

	public ChangedEvent OnChanged;

	public Option Value => Options[CurrentOption];

	protected override void Awake()
	{
		((UIBehaviour)this).Awake();
	}

	public void SetOptions(Option[] options)
	{
		Options = options;
		SetOptionDefault();
	}

	protected void SetOptionFromUser(Option option)
	{
		SetOption(option);
		((UnityEvent<Option>)OnChanged)?.Invoke(option);
	}

	public void SetOption(int i)
	{
		i += Options.Length;
		i %= Options.Length;
		CurrentOption = i;
		((TMP_Text)Text).text = Options[i].Label.translated;
		OptionIcon.Icon = Options[i].Icon;
	}

	public void SetOption(Option option)
	{
		for (int i = 0; i < Options.Length; i++)
		{
			if (Options[i].Value == option.Value)
			{
				SetOption(i);
				break;
			}
		}
	}

	public void SetOptionDefault()
	{
		if (Options == null || Options.Length == 0)
		{
			return;
		}
		for (int i = 0; i < Options.Length; i++)
		{
			if (Options[i].Default)
			{
				SetOption(i);
				return;
			}
		}
		SetOption(0);
	}

	public void OnLeft()
	{
		SetOption(CurrentOption - 1);
		((UnityEvent<Option>)OnChanged)?.Invoke(Value);
	}

	public void OnRight()
	{
		SetOption(CurrentOption + 1);
		((UnityEvent<Option>)OnChanged)?.Invoke(Value);
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)Text))
		{
			((Graphic)Text).color = s.Fg;
		}
		if (Object.op_Implicit((Object)(object)Icon))
		{
			((Graphic)Icon).color = s.Icon;
		}
		if (Object.op_Implicit((Object)(object)OptionIcon))
		{
			((Graphic)OptionIcon).color = s.Fg;
		}
		Image component = ((Component)this).GetComponent<Image>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Graphic)component).color = s.Bg;
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		OpenMenu();
	}

	public void OpenMenu()
	{
		if (Options.Length != 0)
		{
			Menu menu = Make.Menu(Options, Value);
			((UnityEvent<Option>)menu.OnSelected).AddListener((UnityAction<Option>)SetOptionFromUser);
			menu.Popup(base.rectTransform);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class Manager
{
	private static Dictionary<string, GameObject> Prefabs = new Dictionary<string, GameObject>();

	internal static GameObject CreatePrefab(string name)
	{
		if (!Prefabs.TryGetValue(name, out var value))
		{
			value = FileSystem.Load<GameObject>(name, true);
			if ((Object)(object)value == (Object)null)
			{
				throw new Exception("Couldn't find prefab " + name);
			}
			Prefabs[name] = value;
		}
		return Object.Instantiate<GameObject>(value);
	}

	internal static T Create<T>(string prefabName) where T : MonoBehaviour
	{
		return CreatePrefab(prefabName).GetComponent<T>();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class Menu : RustControl
{
	[Serializable]
	public class ChangedEvent : UnityEvent<Option>
	{
	}

	public bool AllowFiltering;

	public int MaxResults = 100;

	public Image Border;

	public Image Background;

	public Option[] Options;

	public RectTransform OptionCanvas;

	public RustInput FilterField;

	[NonSerialized]
	public Option SelectedOption;

	public ChangedEvent OnSelected;

	[NonSerialized]
	public Blocker Blocker;

	protected override void Awake()
	{
		((UIBehaviour)this).Awake();
		((UnityEvent<string>)FilterField.OnValueChanged).AddListener((UnityAction<string>)delegate
		{
			Build();
		});
	}

	public void Build()
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Expected O, but got Unknown
		((Component)((Component)FilterField).transform.parent).gameObject.SetActive(AllowFiltering);
		TransformEx.DestroyAllChildren((Transform)(object)OptionCanvas, true);
		foreach (Option option in GetOptions())
		{
			RustButton rustButton = Make.MenuOption(option.Label, option.Icon);
			((UIBehaviour)(object)rustButton).SetParent((Transform)(object)OptionCanvas);
			((Object)((Component)rustButton).gameObject).hideFlags = (HideFlags)61;
			rustButton.OnPressed.AddListener((UnityAction)delegate
			{
				OnOptionSelected(option);
			});
			if (!string.IsNullOrEmpty(SelectedOption.Value) && option.Value == SelectedOption.Value)
			{
				rustButton.SetPressed(value: true);
			}
		}
	}

	private void OnOptionSelected(Option option)
	{
		((UnityEvent<Option>)OnSelected).Invoke(option);
		Object.Destroy((Object)(object)((Component)this).gameObject);
		if (Object.op_Implicit((Object)(object)Blocker))
		{
			Object.Destroy((Object)(object)((Component)Blocker).gameObject);
		}
	}

	private IEnumerable<Option> GetOptions()
	{
		if (!AllowFiltering)
		{
			return Options.Select((Option x) => x);
		}
		string searchString = FilterField.Text;
		return Options.Where((Option x) => string.IsNullOrEmpty(searchString) || x.Label.translated.Contains(searchString)).Take(MaxResults);
	}

	internal void Popup(RectTransform source)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		Blocker = Make.Blocker();
		((UIBehaviour)(object)Blocker).SetParentRootCanvas((Transform)(object)source);
		Blocker.rectTransform.Fill(-1f, -1f, -1f, -1f);
		float x = ((Component)Blocker).transform.lossyScale.x;
		((UIBehaviour)(object)this).SetParent((UIBehaviour)(object)Blocker);
		Build();
		((Component)OptionCanvas).GetComponent<RustLayout>().DoLayout();
		((Component)this).GetComponent<RustLayout>().DoLayout();
		Vector3[] array = (Vector3[])(object)new Vector3[4];
		source.GetLocalCorners(array);
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = ((Transform)source).TransformPoint(array[i]);
		}
		if (array[0].y / (float)Screen.height < 0.33f)
		{
			base.rectTransform.pivot = new Vector2(0f, 0f);
			base.rectTransform.anchorMin = Vector2.op_Implicit(Vector3.zero);
			base.rectTransform.anchorMax = Vector2.op_Implicit(Vector3.zero);
			base.rectTransform.offsetMin = Vector2.op_Implicit(array[1] / x);
			base.rectTransform.offsetMax = Vector2.op_Implicit(array[1] / x);
			base.rectTransform.SetWidth(source.GetWidth());
		}
		else
		{
			base.rectTransform.pivot = new Vector2(0f, 1f);
			base.rectTransform.anchorMin = Vector2.op_Implicit(Vector3.zero);
			base.rectTransform.anchorMax = Vector2.op_Implicit(Vector3.zero);
			base.rectTransform.offsetMin = Vector2.op_Implicit(array[0] / x);
			base.rectTransform.offsetMax = Vector2.op_Implicit(array[0] / x);
			base.rectTransform.SetWidth(source.GetWidth());
			RestrainToScreen();
		}
	}

	private void RestrainToScreen()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		((Component)OptionCanvas).GetComponent<RustLayout>().DoLayout();
		((Component)this).GetComponent<RustLayout>().DoLayout();
		int num = 4;
		if (base.rectTransform.offsetMin.y < (float)num)
		{
			float amount = Mathf.Abs(base.rectTransform.offsetMin.y) + (float)num;
			base.rectTransform.MoveY(amount);
		}
		if (base.rectTransform.offsetMin.y > (float)(Screen.height - 4))
		{
			float num2 = Mathf.Abs((float)Screen.height - base.rectTransform.offsetMin.y) + (float)num;
			base.rectTransform.MoveY(0f - num2);
		}
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyStyle(s);
		if (Object.op_Implicit((Object)(object)Background))
		{
			((Graphic)Background).color = s.Bg;
		}
		if (Object.op_Implicit((Object)(object)Border))
		{
			((Graphic)Border).color = s.Fg;
		}
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/Button")]
public class RustButton : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, ILayoutElement
{
	public Image Background;

	public RustText Text;

	public RustText SubText;

	public RustIcon Icon;

	public Image IconImage;

	public UnityEvent OnPressed;

	public UnityEvent OnReleased;

	public bool IsToggle;

	public bool UnpressSiblings;

	public bool PreventToggleOff;

	public Transform TabPanelTarget;

	public Vector4 TextMargin = new Vector4(30f, 5f, 10f, 5f);

	public Vector4 TextMarginNoIcon = new Vector4(10f, 5f, 10f, 5f);

	public bool Value
	{
		get
		{
			return IsPressed;
		}
		set
		{
			if (value != Value)
			{
				if (value)
				{
					CurrentState |= State.Pressed;
				}
				else
				{
					CurrentState &= ~State.Pressed;
				}
				ApplyStyles();
			}
		}
	}

	public bool AutoSize
	{
		get
		{
			return Text.AutoSizeParent;
		}
		set
		{
			Text.AutoSizeParent = value;
		}
	}

	public float minWidth
	{
		get
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0f;
			}
			Rect rect = ((TMP_Text)Text).rectTransform.rect;
			return ((Rect)(ref rect)).width;
		}
	}

	public float preferredWidth
	{
		get
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0f;
			}
			Rect rect = ((TMP_Text)Text).rectTransform.rect;
			return ((Rect)(ref rect)).width;
		}
	}

	public float flexibleWidth
	{
		get
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0f;
			}
			Rect rect = ((TMP_Text)Text).rectTransform.rect;
			return ((Rect)(ref rect)).width;
		}
	}

	public float minHeight
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0f;
			}
			return ((TMP_Text)Text).minHeight;
		}
	}

	public float preferredHeight
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0f;
			}
			return ((TMP_Text)Text).preferredHeight;
		}
	}

	public float flexibleHeight
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0f;
			}
			return ((TMP_Text)Text).flexibleHeight;
		}
	}

	public int layoutPriority
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Text))
			{
				return 0;
			}
			return ((TMP_Text)Text).layoutPriority;
		}
	}

	public void Press()
	{
		if (IsDisabled)
		{
			return;
		}
		if (IsToggle)
		{
			if (!PreventToggleOff || !Value)
			{
				Toggle(!Value);
			}
		}
		else
		{
			Toggle(v: true, forced: true);
		}
	}

	public void Unpress()
	{
		if (!IsDisabled)
		{
			if (!IsToggle)
			{
				Toggle(v: false, forced: true);
			}
			ApplyStyles();
		}
	}

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if ((int)eventData.button == 0)
		{
			Press();
		}
	}

	public void SetToggleTrue()
	{
		Toggle(v: true);
	}

	public void SetToggleFalse()
	{
		Toggle(v: false);
	}

	public void Toggle(bool v, bool forced = false)
	{
		if (v)
		{
			if (UnpressSiblings)
			{
				DoUnpressSiblings();
			}
			if (Value && !forced)
			{
				return;
			}
			CurrentState |= State.Pressed;
			OnPressed.Invoke();
			ToggleTabPanel(onOff: true);
		}
		else
		{
			if (!Value && !forced)
			{
				return;
			}
			CurrentState &= ~State.Pressed;
			OnReleased.Invoke();
			ToggleTabPanel(onOff: false);
		}
		ApplyStyles();
	}

	private void ToggleTabPanel(bool onOff)
	{
		if (!((Object)(object)TabPanelTarget == (Object)null))
		{
			Transform val = TabPanelTarget.Find(((Object)((Component)this).gameObject).name);
			if (!((Object)(object)val == (Object)null))
			{
				((Component)val).gameObject.SetActive(onOff);
			}
		}
	}

	private void DoUnpressSiblings()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Expected O, but got Unknown
		foreach (Transform item in ((Component)this).transform.parent)
		{
			Transform val = item;
			if (!((Object)(object)val == (Object)(object)((Component)this).transform))
			{
				RustButton component = ((Component)val).GetComponent<RustButton>();
				if (!((Object)(object)component == (Object)null))
				{
					component.Toggle(v: false);
				}
			}
		}
	}

	public virtual void OnPointerUp(PointerEventData eventData)
	{
		Unpress();
	}

	protected override void OnDisable()
	{
		((UIBehaviour)this).OnDisable();
		if (!IsToggle && Value)
		{
			CurrentState &= ~State.Pressed;
			ApplyStyles();
		}
		if (!IsToggle && CurrentState.HasFlag(State.Hovered))
		{
			CurrentState &= ~State.Hovered;
			ApplyStyles();
		}
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)Background))
		{
			((Graphic)Background).color = s.Bg;
		}
		if (Object.op_Implicit((Object)(object)Text))
		{
			((Graphic)Text).color = s.Fg;
		}
		if (Object.op_Implicit((Object)(object)SubText))
		{
			((Graphic)SubText).color = Color.Lerp(s.Bg, s.Fg, 0.5f);
		}
		if (Object.op_Implicit((Object)(object)Icon))
		{
			((Graphic)Icon).color = s.Icon;
		}
		if (Object.op_Implicit((Object)(object)IconImage))
		{
			((Graphic)IconImage).color = s.Icon;
		}
		if (Object.op_Implicit((Object)(object)Text))
		{
			Vector4 val = (((!Object.op_Implicit((Object)(object)Icon) || Icon.Icon == Icons.None) && !Object.op_Implicit((Object)(object)IconImage)) ? TextMarginNoIcon : TextMargin);
			if (((TMP_Text)Text).margin != val)
			{
				((TMP_Text)Text).margin = val;
				Text.DoAutoSize();
			}
			if ((Object)(object)SubText != (Object)null && ((TMP_Text)SubText).margin != val)
			{
				((TMP_Text)SubText).margin = val;
				SubText.DoAutoSize();
			}
		}
	}

	public void CalculateLayoutInputHorizontal()
	{
		RustText text = Text;
		if (text != null)
		{
			((TextMeshProUGUI)text).CalculateLayoutInputHorizontal();
		}
	}

	public void CalculateLayoutInputVertical()
	{
		RustText text = Text;
		if (text != null)
		{
			((TextMeshProUGUI)text).CalculateLayoutInputVertical();
		}
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class RustButtonGroup : RustControl
{
	[Serializable]
	public class ChangedEvent : UnityEvent<Option>
	{
	}

	public Option[] Options;

	public string ButtonStyle = "ButtonGroup.Normal";

	private int CurrentOption;

	public ChangedEvent OnChanged;

	public Option Value => Options[CurrentOption];

	protected override void Awake()
	{
		((UIBehaviour)this).Awake();
		BuildContents();
	}

	public void SetOption(int i)
	{
		while (i < 0)
		{
			i += Options.Length;
		}
		i %= Options.Length;
		CurrentOption = i;
		((Component)((Component)this).transform.GetChild(i)).GetComponent<RustButton>().Toggle(v: true);
	}

	public void SetOption(string value)
	{
		for (int i = 0; i < Options.Length; i++)
		{
			if (Options[i].Value == value)
			{
				SetOption(i);
				break;
			}
		}
	}

	private void ButtonPressed(int i)
	{
		if (CurrentOption != i)
		{
			SetOption(i);
			((UnityEvent<Option>)OnChanged).Invoke(Value);
		}
	}

	public void SetOptionDefault()
	{
		for (int i = 0; i < Options.Length; i++)
		{
			if (Options[i].Default)
			{
				SetOption(i);
				return;
			}
		}
		SetOption(0);
	}

	public void BuildContents()
	{
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Expected O, but got Unknown
		for (int num = ((Component)this).transform.childCount - 1; num >= 0; num--)
		{
			Object.DestroyImmediate((Object)(object)((Component)((Component)this).transform.GetChild(num)).gameObject);
		}
		if (Options == null)
		{
			return;
		}
		int num2 = 0;
		Option[] options = Options;
		for (int i = 0; i < options.Length; i++)
		{
			Option option = options[i];
			int buttonNumber = num2;
			RustButton rustButton = Make.Button(option.Label, option.Icon, toggle: true, ButtonStyle, autoSize: true);
			((Object)((Component)rustButton).gameObject).hideFlags = (HideFlags)1;
			rustButton.UnpressSiblings = true;
			rustButton.PreventToggleOff = true;
			rustButton.OnPressed.AddListener((UnityAction)delegate
			{
				ButtonPressed(buttonNumber);
			});
			((UIBehaviour)(object)rustButton).SetParent(((Component)this).transform);
			rustButton.ApplyStyles();
			num2++;
		}
		SetOptionDefault();
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;

public class RustControl : UIBehaviour, IPointerEnterHandler, IEventSystemHandler, IPointerExitHandler
{
	[Flags]
	public enum State
	{
		Normal = 1,
		Hovered = 2,
		Pressed = 4,
		Active = 8,
		Disabled = 0x10
	}

	protected static bool IsDragging;

	[SerializeField]
	protected StyleAsset _styles;

	[NonSerialized]
	public RustWrapper FormField;

	[InspectorFlags]
	public State CurrentState;

	public virtual StyleAsset Styles
	{
		get
		{
			return _styles;
		}
		set
		{
			_styles = value;
			ApplyStyles();
		}
	}

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	public virtual bool IsDisabled => (CurrentState & State.Disabled) != 0;

	public virtual bool IsPressed => (CurrentState & State.Pressed) != 0;

	public virtual bool IsHovered => (CurrentState & State.Hovered) != 0;

	public virtual StyleColorSet CurrentStyleCollection
	{
		get
		{
			StyleColorSet result = new StyleColorSet(Styles.Normal);
			if (IsHovered && !IsDragging)
			{
				result.Apply(Styles.Hovered);
			}
			if (IsPressed)
			{
				result.Apply(Styles.Pressed);
			}
			if (IsDisabled)
			{
				result.Apply(Styles.Disabled);
			}
			return result;
		}
	}

	protected override void OnEnable()
	{
		((UIBehaviour)this).OnEnable();
		ApplyStyles();
	}

	public virtual void OnPointerEnter(PointerEventData eventData)
	{
		CurrentState |= State.Hovered;
		ApplyStyles();
	}

	public virtual void OnPointerExit(PointerEventData eventData)
	{
		CurrentState &= ~State.Hovered;
		ApplyStyles();
	}

	public virtual void SetDisabled(bool value)
	{
		if (IsDisabled != value)
		{
			if (!value)
			{
				CurrentState &= ~State.Disabled;
			}
			else
			{
				CurrentState |= State.Disabled;
			}
			ApplyStyles();
		}
	}

	public virtual void SetPressed(bool value)
	{
		if (IsPressed != value)
		{
			if (!value)
			{
				CurrentState &= ~State.Pressed;
			}
			else
			{
				CurrentState |= State.Pressed;
			}
			ApplyStyles();
		}
	}

	public virtual void ApplyStyles()
	{
		if (!((Object)(object)Styles == (Object)null))
		{
			ApplyStyle(CurrentStyleCollection);
		}
	}

	protected virtual void ApplyStyle(StyleColorSet s)
	{
	}
}


using Facepunch.Flexbox;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/RustFlexText")]
public class RustFlexText : RustText, IFlexNode
{
	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow = 1;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength FlexMinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength FlexMaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength FlexMinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength FlexMaxHeight;

	private bool _isDirty;

	private float _preferredWidth;

	private float _preferredHeight;

	RectTransform IFlexNode.Transform => (RectTransform)((TMP_Text)this).transform;

	bool IFlexNode.IsActive => ((Behaviour)this).isActiveAndEnabled;

	bool IFlexNode.IsAbsolute => false;

	bool IFlexNode.IsDirty => _isDirty;

	FlexLength IFlexNode.MinWidth => FlexMinWidth;

	FlexLength IFlexNode.MaxWidth => FlexMaxWidth;

	FlexLength IFlexNode.MinHeight => FlexMinHeight;

	FlexLength IFlexNode.MaxHeight => FlexMaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	protected override void OnEnable()
	{
		((TextMeshProUGUI)this).OnEnable();
		((Graphic)this).SetLayoutDirty();
	}

	protected override void OnDisable()
	{
		((TextMeshProUGUI)this).OnDisable();
	}

	public override void SetLayoutDirty()
	{
		_isDirty = true;
		((TextMeshProUGUI)this).SetLayoutDirty();
		Transform parent = ((TMP_Text)this).transform.parent;
		IFlexNode val = default(IFlexNode);
		if ((Object)(object)parent != (Object)null && ((Component)parent).TryGetComponent<IFlexNode>(ref val) && val.IsActive)
		{
			val.SetLayoutDirty(false);
		}
	}

	public override void DoAutoSize()
	{
	}

	void IFlexNode.SetupTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		RectTransform val = (RectTransform)((TMP_Text)this).transform;
		((Transform)val).localRotation = Quaternion.identity;
		val.pivot = new Vector2(0f, 1f);
		val.anchorMin = new Vector2(0f, 1f);
		val.anchorMax = new Vector2(0f, 1f);
	}

	void IFlexNode.SetLayoutDirty(bool force)
	{
		if (force || ((UIBehaviour)this).IsActive())
		{
			((Graphic)this).SetLayoutDirty();
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		float valueOrDefault = ((FlexLength)(ref FlexMaxWidth)).GetValueOrDefault(float.PositiveInfinity);
		float valueOrDefault2 = ((FlexLength)(ref FlexMaxHeight)).GetValueOrDefault(float.PositiveInfinity);
		Vector2 preferredValues = ((TMP_Text)this).GetPreferredValues(valueOrDefault, valueOrDefault2);
		_preferredWidth = Mathf.Max(Mathf.Min(preferredValues.x, valueOrDefault), ((FlexLength)(ref FlexMinWidth)).GetValueOrDefault(0f));
		_preferredHeight = Mathf.Max(Mathf.Min(preferredValues.y, valueOrDefault2), ((FlexLength)(ref FlexMinHeight)).GetValueOrDefault(0f));
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
	}

	void IFlexNode.MeasureVertical()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector2 sizeDelta = ((RectTransform)((TMP_Text)this).transform).sizeDelta;
		float valueOrDefault = ((FlexLength)(ref FlexMaxWidth)).GetValueOrDefault(float.PositiveInfinity);
		float valueOrDefault2 = ((FlexLength)(ref FlexMaxHeight)).GetValueOrDefault(float.PositiveInfinity);
		Vector2 preferredValues = ((TMP_Text)this).GetPreferredValues(sizeDelta.x, valueOrDefault2);
		_preferredWidth = Mathf.Max(Mathf.Min(preferredValues.x, valueOrDefault), ((FlexLength)(ref FlexMinWidth)).GetValueOrDefault(0f));
		_preferredHeight = Mathf.Max(Mathf.Min(preferredValues.y, valueOrDefault2), ((FlexLength)(ref FlexMinHeight)).GetValueOrDefault(0f));
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
		_isDirty = false;
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localScale = ((Transform)(RectTransform)((TMP_Text)this).transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = _preferredWidth;
		preferredHeight = _preferredHeight;
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

[AddComponentMenu("Rust/UI/RustIcon")]
public class RustIcon : TextMeshProUGUI
{
	[SerializeField]
	private Icons _icon;

	public Icons Icon
	{
		get
		{
			return _icon;
		}
		set
		{
			_icon = value;
			((TMP_Text)this).text = $"{(char)value}";
		}
	}

	public void SetIcon(Icons newIcon)
	{
		Icon = newIcon;
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/Image Button")]
public class RustImageButton : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, ILayoutElement
{
	public Image Background;

	public Image Icon;

	public UnityEvent OnPressed;

	public UnityEvent OnReleased;

	public bool IsToggle;

	public bool UnpressSiblings;

	public bool PreventToggleOff;

	public Transform TabPanelTarget;

	public Sprite PressedImage;

	public Sprite UnpressedImage;

	public bool Value
	{
		get
		{
			return IsPressed;
		}
		set
		{
			if (value != Value)
			{
				if (value)
				{
					CurrentState |= State.Pressed;
				}
				else
				{
					CurrentState &= ~State.Pressed;
				}
				ApplyStyles();
			}
		}
	}

	public float minWidth
	{
		get
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0f;
			}
			Rect rect = ((Graphic)Icon).rectTransform.rect;
			return ((Rect)(ref rect)).width;
		}
	}

	public float preferredWidth
	{
		get
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0f;
			}
			Rect rect = ((Graphic)Icon).rectTransform.rect;
			return ((Rect)(ref rect)).width;
		}
	}

	public float flexibleWidth
	{
		get
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0f;
			}
			Rect rect = ((Graphic)Icon).rectTransform.rect;
			return ((Rect)(ref rect)).width;
		}
	}

	public float minHeight
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0f;
			}
			return Icon.minHeight;
		}
	}

	public float preferredHeight
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0f;
			}
			return Icon.preferredHeight;
		}
	}

	public float flexibleHeight
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0f;
			}
			return Icon.flexibleHeight;
		}
	}

	public int layoutPriority
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)Icon))
			{
				return 0;
			}
			return Icon.layoutPriority;
		}
	}

	public void Press()
	{
		if (IsDisabled)
		{
			return;
		}
		if (IsToggle)
		{
			if (!PreventToggleOff || !Value)
			{
				Toggle(!Value);
			}
		}
		else
		{
			Toggle(v: true, forced: true);
		}
	}

	public void Unpress()
	{
		if (!IsDisabled)
		{
			if (!IsToggle)
			{
				CurrentState &= ~State.Pressed;
			}
			ApplyStyles();
		}
	}

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if ((int)eventData.button == 0)
		{
			Press();
		}
	}

	public void Toggle(bool v, bool forced = false)
	{
		if (v)
		{
			if (UnpressSiblings)
			{
				DoUnpressSiblings();
			}
			if (Value && !forced)
			{
				return;
			}
			CurrentState |= State.Pressed;
			OnPressed.Invoke();
			ToggleTabPanel(onOff: true);
		}
		else
		{
			if (!Value && !forced)
			{
				return;
			}
			CurrentState &= ~State.Pressed;
			OnReleased.Invoke();
			ToggleTabPanel(onOff: false);
		}
		ApplyStyles();
	}

	private void ToggleTabPanel(bool onOff)
	{
		if (!((Object)(object)TabPanelTarget == (Object)null))
		{
			Transform val = TabPanelTarget.Find(((Object)((Component)this).gameObject).name);
			if (!((Object)(object)val == (Object)null))
			{
				((Component)val).gameObject.SetActive(onOff);
			}
		}
	}

	private void DoUnpressSiblings()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Expected O, but got Unknown
		foreach (Transform item in ((Component)this).transform.parent)
		{
			Transform val = item;
			if (!((Object)(object)val == (Object)(object)((Component)this).transform))
			{
				RustImageButton component = ((Component)val).GetComponent<RustImageButton>();
				if (!((Object)(object)component == (Object)null))
				{
					component.Toggle(v: false);
				}
			}
		}
	}

	public virtual void OnPointerUp(PointerEventData eventData)
	{
		Unpress();
	}

	protected override void OnDisable()
	{
		((UIBehaviour)this).OnDisable();
		if (!IsToggle && Value)
		{
			CurrentState &= ~State.Pressed;
			ApplyStyles();
		}
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)Background))
		{
			((Graphic)Background).color = s.Bg;
		}
		if (Object.op_Implicit((Object)(object)Icon))
		{
			((Graphic)Icon).color = s.Icon;
			Icon.sprite = (Value ? PressedImage : UnpressedImage);
		}
	}

	public void CalculateLayoutInputHorizontal()
	{
		Image icon = Icon;
		if (icon != null)
		{
			icon.CalculateLayoutInputHorizontal();
		}
	}

	public void CalculateLayoutInputVertical()
	{
		Image icon = Icon;
		if (icon != null)
		{
			icon.CalculateLayoutInputVertical();
		}
	}
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RustInput : RustControl
{
	[Serializable]
	public class ChangedEvent : UnityEvent<string>
	{
	}

	public TMP_InputField InputField;

	public Image Background;

	public ChangedEvent OnValueChanged;

	public ChangedEvent OnEndEdit;

	public ChangedEvent OnSubmit;

	public RustText Placeholder => InputField.placeholder as RustText;

	public bool IsFocused => InputField.isFocused;

	public string Value => Text;

	public string Text
	{
		get
		{
			return InputField.text;
		}
		set
		{
			InputField.text = value;
		}
	}

	public override StyleColorSet CurrentStyleCollection
	{
		get
		{
			StyleColorSet currentStyleCollection = base.CurrentStyleCollection;
			if (IsFocused)
			{
				currentStyleCollection.Apply(Styles.Pressed);
			}
			if (IsDisabled)
			{
				currentStyleCollection.Apply(Styles.Disabled);
			}
			return currentStyleCollection;
		}
	}

	protected override void Awake()
	{
		((UnityEvent<string>)(object)InputField.onValueChanged).AddListener((UnityAction<string>)delegate(string x)
		{
			((UnityEvent<string>)OnValueChanged).Invoke(x);
		});
		((UnityEvent<string>)(object)InputField.onEndEdit).AddListener((UnityAction<string>)delegate(string x)
		{
			((UnityEvent<string>)OnEndEdit).Invoke(x);
		});
		((UnityEvent<string>)(object)InputField.onSubmit).AddListener((UnityAction<string>)delegate(string x)
		{
			((UnityEvent<string>)OnSubmit).Invoke(x);
		});
		((UnityEvent<string>)(object)InputField.onSelect).AddListener((UnityAction<string>)delegate
		{
			ApplyStyles();
		});
		((UnityEvent<string>)(object)InputField.onDeselect).AddListener((UnityAction<string>)delegate
		{
			ApplyStyles();
		});
		((UIBehaviour)this).Awake();
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyStyle(s);
		if (Object.op_Implicit((Object)(object)Background))
		{
			((Graphic)Background).color = s.Bg;
		}
		if (Object.op_Implicit((Object)(object)InputField.textComponent))
		{
			((Graphic)InputField.textComponent).color = s.Fg;
		}
		if (Object.op_Implicit((Object)(object)InputField.placeholder))
		{
			((Graphic)(InputField.placeholder as RustText)).color = s.Icon;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class RustLayout : UIBehaviour, ILayoutGroup, ILayoutController, IAutoLayout
{
	public enum LayoutMode
	{
		Top,
		Left,
		Right,
		Bottom
	}

	public LayoutMode Mode;

	public bool ReverseOrder;

	public float Spacing;

	public RectOffset Padding;

	[FormerlySerializedAs("SetChildrenWidth")]
	[Tooltip("Scale the children to fill in the opposite direction to the way you're laying out")]
	public bool ChildrenFill;

	[FormerlySerializedAs("SetHeight")]
	[Tooltip("Resize this container to fit children on the direction you're laying out")]
	public bool ResizeToChildren;

	[Tooltip("Resize this container to fit children on the opposite direction to the one you're laying out (does nothing if ChildrenFill is enabled)")]
	public bool ResizeToChildrenOpposite;

	public RectTransform[] IgnoreLayout;

	public int MaxHeight;

	[Tooltip("We'll call layout on this if our size changes")]
	public RustLayout ParentLayout;

	private bool doingLayout;

	private bool changedSize;

	protected override void Awake()
	{
		((UIBehaviour)this).OnTransformParentChanged();
	}

	protected override void OnEnable()
	{
		DoLayout();
	}

	public virtual void SetLayoutHorizontal()
	{
		DoLayout();
	}

	public virtual void SetLayoutVertical()
	{
		DoLayout();
	}

	public virtual void DoLayout()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		if (doingLayout)
		{
			return;
		}
		if (Padding == null)
		{
			Padding = new RectOffset();
		}
		doingLayout = true;
		try
		{
			changedSize = false;
			if (Mode == LayoutMode.Top)
			{
				DoTopLayout((Edge)2);
			}
			if (Mode == LayoutMode.Bottom)
			{
				DoTopLayout((Edge)3);
			}
			if (Mode == LayoutMode.Left)
			{
				DoHorizontalLayout((Edge)0);
			}
			if (Mode == LayoutMode.Right)
			{
				DoHorizontalLayout((Edge)1);
			}
			if (changedSize)
			{
				ParentLayout?.DoLayout();
			}
		}
		finally
		{
			doingLayout = false;
		}
	}

	protected override void OnTransformParentChanged()
	{
		ParentLayout = null;
		if (Object.op_Implicit((Object)(object)((Component)this).transform.parent))
		{
			ParentLayout = ((Component)((Component)this).transform.parent).GetComponent<RustLayout>();
		}
	}

	private void DoHorizontalLayout(Edge edge)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Rect rect = val.rect;
		Vector2 size = ((Rect)(ref rect)).size;
		int childCount = ((Component)this).transform.childCount;
		float num = 0f;
		float num2 = (((int)edge == 0) ? Padding.left : Padding.right);
		float num3 = 0f;
		for (int i = 0; i < childCount; i++)
		{
			Transform child = ((Component)this).transform.GetChild(ReverseOrder ? (childCount - i - 1) : i);
			RectTransform val2 = (RectTransform)(object)((child is RectTransform) ? child : null);
			if (((Component)val2).gameObject.activeSelf && !Ignoring(val2))
			{
				rect = val2.rect;
				Vector2 size2 = ((Rect)(ref rect)).size;
				val2.SetInsetAndSizeFromParentEdge(edge, num2, size2.x);
				if (ChildrenFill)
				{
					val2.SetInsetAndSizeFromParentEdge((Edge)2, (float)Padding.top, size.y - (float)Padding.vertical);
				}
				else
				{
					val2.SetInsetAndSizeFromParentEdge((Edge)2, (float)Padding.top, size2.y);
				}
				num2 += size2.x + Spacing;
				num3 = Spacing;
				if (size2.y > num)
				{
					num = size2.y;
				}
			}
		}
		num2 -= num3;
		num2 += (float)Padding.right;
		bool flag = false;
		if (ResizeToChildren && size.x != num2)
		{
			changedSize = true;
			val.SetWidth(num2);
			flag = true;
		}
		if (ResizeToChildrenOpposite && !ChildrenFill && size.y != num)
		{
			changedSize = true;
			val.SetHeight((float)Padding.top + num + (float)Padding.bottom);
			flag = true;
		}
		if (flag)
		{
			ILayoutGroup componentInParent = ((Component)this).GetComponentInParent<ILayoutGroup>();
			if (componentInParent != null)
			{
				((ILayoutController)componentInParent).SetLayoutHorizontal();
			}
			if (componentInParent != null)
			{
				((ILayoutController)componentInParent).SetLayoutVertical();
			}
		}
	}

	private void DoTopLayout(Edge edge)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Invalid comparison between Unknown and I4
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		RectTransform val = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Rect rect = val.rect;
		Vector2 size = ((Rect)(ref rect)).size;
		int childCount = ((Component)this).transform.childCount;
		float num = 0f;
		float num2 = (((int)edge == 2) ? Padding.top : Padding.bottom);
		float num3 = 0f;
		for (int i = 0; i < childCount; i++)
		{
			Transform child = ((Component)this).transform.GetChild(ReverseOrder ? (childCount - i - 1) : i);
			RectTransform val2 = (RectTransform)(object)((child is RectTransform) ? child : null);
			if (Object.op_Implicit((Object)(object)val2) && Object.op_Implicit((Object)(object)((Component)val2).gameObject) && ((Component)val2).gameObject.activeSelf && !Ignoring(val2))
			{
				rect = val2.rect;
				Vector2 size2 = ((Rect)(ref rect)).size;
				val2.SetInsetAndSizeFromParentEdge(edge, num2, size2.y);
				if (ChildrenFill)
				{
					val2.SetInsetAndSizeFromParentEdge((Edge)0, (float)Padding.left, size.x - (float)Padding.horizontal);
				}
				else
				{
					val2.SetInsetAndSizeFromParentEdge((Edge)0, (float)Padding.left, size2.x);
				}
				num2 += size2.y + Spacing;
				num3 = Spacing;
				if (size2.x > num)
				{
					num = size2.x;
				}
			}
		}
		num2 -= num3;
		num2 += (float)Padding.bottom;
		if (MaxHeight > 0)
		{
			num2 = Mathf.Min((float)MaxHeight, num2);
		}
		bool flag = false;
		if (ResizeToChildren && size.y != num2)
		{
			changedSize = true;
			val.SetHeight(num2);
			flag = true;
		}
		if (ResizeToChildrenOpposite && !ChildrenFill && size.x != num)
		{
			changedSize = true;
			val.SetWidth((float)Padding.left + num + (float)Padding.right);
			flag = true;
		}
		if (flag)
		{
			ILayoutGroup componentInParent = ((Component)this).GetComponentInParent<ILayoutGroup>();
			if (componentInParent != null)
			{
				((ILayoutController)componentInParent).SetLayoutHorizontal();
			}
			if (componentInParent != null)
			{
				((ILayoutController)componentInParent).SetLayoutVertical();
			}
		}
	}

	private bool Ignoring(RectTransform child)
	{
		if (IgnoreLayout == null)
		{
			return false;
		}
		for (int i = 0; i < IgnoreLayout.Length; i++)
		{
			if ((Object)(object)child == (Object)(object)IgnoreLayout[i])
			{
				return true;
			}
		}
		return false;
	}

	protected void SetDirty()
	{
		if (((UIBehaviour)this).IsActive())
		{
			Transform transform = ((Component)this).transform;
			LayoutRebuilder.MarkLayoutForRebuild((RectTransform)(object)((transform is RectTransform) ? transform : null));
		}
	}

	protected override void OnRectTransformDimensionsChange()
	{
		((UIBehaviour)this).OnRectTransformDimensionsChange();
		SetDirty();
	}

	protected virtual void OnTransformChildrenChanged()
	{
		SetDirty();
	}
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RustOption : RustControl
{
	[Serializable]
	public class ChangedEvent : UnityEvent<Option>
	{
	}

	public RustButton Left;

	public RustButton Right;

	public RustText Text;

	public Option[] Options;

	private int CurrentOption;

	public ChangedEvent OnChanged;

	public Option Value => Options[CurrentOption];

	protected override void Awake()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		((UIBehaviour)this).Awake();
		Left.OnPressed.AddListener(new UnityAction(OnLeft));
		Right.OnPressed.AddListener(new UnityAction(OnRight));
	}

	public void SetOptions(Option[] options)
	{
		Options = options;
		SetOptionDefault();
	}

	public void SetOption(int i)
	{
		i += Options.Length;
		i %= Options.Length;
		CurrentOption = i;
		((TMP_Text)Text).text = Options[i].Label.translated;
	}

	public void SetOptionDefault()
	{
		if (Options == null || Options.Length == 0)
		{
			return;
		}
		for (int i = 0; i < Options.Length; i++)
		{
			if (Options[i].Default)
			{
				SetOption(i);
				return;
			}
		}
		SetOption(0);
	}

	public void OnLeft()
	{
		SetOption(CurrentOption - 1);
		((UnityEvent<Option>)OnChanged)?.Invoke(Value);
	}

	public void OnRight()
	{
		SetOption(CurrentOption + 1);
		((UnityEvent<Option>)OnChanged)?.Invoke(Value);
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)Text))
		{
			((Graphic)Text).color = s.Fg;
		}
		Image component = ((Component)this).GetComponent<Image>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Graphic)component).color = s.Bg;
		}
	}
}


using System;
using Rust.UI;

[Serializable]
public struct Option
{
	public Icons Icon;

	public string Value;

	public Phrase Label;

	public bool Default;

	public Option(string token, string english, string value = null, bool isdefault = false, Icons icon = Icons.None)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		Icon = icon;
		Label = new Phrase(token, english);
		Value = value ?? token ?? english;
		Default = isdefault;
	}

	public Option(Phrase phrase, string value, bool isdefault = false, Icons icon = Icons.None)
	{
		Icon = icon;
		Label = phrase;
		Value = value;
		Default = isdefault;
	}

	public Option(Icons icon, string value = null, bool isdefault = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		Icon = icon;
		Label = new Phrase("", "");
		Value = value;
		Default = isdefault;
	}
}


using System;
using Rust.UI;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = true)]
public class OptionAttribute : Attribute
{
	public Icons Icon;

	public Phrase Label;

	public string Value;

	public bool Default;

	public OptionAttribute(string token, string english, string value = null, bool isdefault = false, Icons icon = Icons.None)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		Icon = icon;
		Label = new Phrase(token, english);
		Value = value ?? token ?? english;
		Default = isdefault;
	}

	public OptionAttribute(Icons icon, string value = null, bool isdefault = false)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		Icon = icon;
		Label = new Phrase("", "");
		Value = value;
		Default = isdefault;
	}

	public Option GetOption()
	{
		return new Option(Label, Value, Default, Icon);
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RustSlider : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler, IInitializePotentialDragHandler
{
	[Serializable]
	public class ChangedEvent : UnityEvent<float>
	{
	}

	public RustInput NumberInput;

	public Image SliderCanvas;

	public string DecimalFormat = "0.00";

	public float MinValue;

	public float MaxValue;

	public bool Integer;

	public float ValueInternal;

	public ChangedEvent OnChanged;

	protected float lastCallbackValue;

	public virtual float Value
	{
		get
		{
			return ValueInternal;
		}
		set
		{
			value = Mathf.Clamp(value, MinValue, MaxValue);
			if (Integer)
			{
				value = Mathf.Round(value);
			}
			if (ValueInternal != value)
			{
				ValueInternal = value;
			}
			string text = (Integer ? $"{(int)value}" : string.Format("{0:" + DecimalFormat + "}", value));
			if ((Object)(object)NumberInput != (Object)null && !NumberInput.IsFocused && NumberInput.Text != text)
			{
				NumberInput.Text = text;
			}
			SliderCanvas.fillAmount = ValueNormalized;
			if (lastCallbackValue != value)
			{
				lastCallbackValue = value;
				((UnityEvent<float>)OnChanged)?.Invoke(value);
			}
		}
	}

	public float ValueNormalized
	{
		get
		{
			return Mathf.InverseLerp(MinValue, MaxValue, Value);
		}
		set
		{
			Value = MinValue + (MaxValue - MinValue) * value;
		}
	}

	protected override void Awake()
	{
		((UIBehaviour)this).Awake();
		if ((Object)(object)NumberInput != (Object)null)
		{
			((UnityEvent<string>)NumberInput.OnValueChanged).AddListener((UnityAction<string>)TextChanged);
			((UnityEvent<string>)NumberInput.OnEndEdit).AddListener((UnityAction<string>)TextChanged);
		}
	}

	public void TextChanged(string text)
	{
		if (float.TryParse(text, out var result))
		{
			Value = result;
		}
	}

	public void SliderChanged(float slider)
	{
		Value = slider;
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyStyle(s);
		((Graphic)SliderCanvas).color = s.Fg;
		((Graphic)((Component)this).GetComponent<Image>()).color = s.Bg;
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		UpdateDrag(eventData.position, eventData.pressEventCamera);
		CurrentState |= State.Pressed;
		RustControl.IsDragging = true;
		ApplyStyles();
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		CurrentState &= ~State.Pressed;
		RustControl.IsDragging = false;
		ApplyStyles();
	}

	public void OnInitializePotentialDrag(PointerEventData eventData)
	{
		eventData.useDragThreshold = false;
	}

	public void OnDrag(PointerEventData eventData)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		UpdateDrag(eventData.position, eventData.pressEventCamera);
	}

	private void UpdateDrag(Vector2 pos, Camera cam)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(((Graphic)SliderCanvas).rectTransform, pos, cam, ref val))
		{
			Vector2 val2 = val;
			Rect rect = ((Graphic)SliderCanvas).rectTransform.rect;
			val = val2 - ((Rect)(ref rect)).position;
			ref float x = ref val.x;
			float num = x;
			rect = ((Graphic)SliderCanvas).rectTransform.rect;
			x = num / ((Rect)(ref rect)).width;
			ValueNormalized = val.x;
		}
	}
}


public enum StyleGroup
{
	Normal,
	Hovered,
	Presed,
	Disabled
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class RustStyler : MonoBehaviour
{
	[SerializeField]
	protected StyleAsset _styles;

	[SerializeField]
	protected StyleGroup _group;

	public Graphic[] Foreground;

	public Graphic[] Background;

	public Graphic[] Icon;

	public StyleAsset Styles
	{
		get
		{
			return _styles;
		}
		set
		{
			_styles = value;
			ApplyStyles();
		}
	}

	public StyleGroup Group
	{
		get
		{
			return _group;
		}
		set
		{
			_group = value;
			ApplyStyles();
		}
	}

	private void ApplyStyles()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		StyleAsset.Group styleGroup = GetStyleGroup();
		if (styleGroup == null)
		{
			return;
		}
		Graphic[] foreground = Foreground;
		foreach (Graphic val in foreground)
		{
			if (!((Object)(object)val == (Object)null))
			{
				val.color = styleGroup.Fg;
			}
		}
		foreground = Background;
		foreach (Graphic val2 in foreground)
		{
			if (!((Object)(object)val2 == (Object)null))
			{
				val2.color = styleGroup.Bg;
			}
		}
		foreground = Icon;
		foreach (Graphic val3 in foreground)
		{
			if (!((Object)(object)val3 == (Object)null))
			{
				val3.color = styleGroup.Icon;
			}
		}
	}

	private StyleAsset.Group GetStyleGroup()
	{
		if ((Object)(object)Styles == (Object)null)
		{
			return null;
		}
		return Group switch
		{
			StyleGroup.Hovered => Styles.Hovered, 
			StyleGroup.Presed => Styles.Pressed, 
			StyleGroup.Disabled => Styles.Disabled, 
			_ => Styles.Normal, 
		};
	}
}


using System;
using RTLTMPro;
using Rust.Localization;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/RustText")]
public class RustText : TextMeshProUGUI, ILocalize
{
	public bool IsLocalized;

	public string Token;

	[TextArea]
	public string English;

	[NonSerialized]
	public Phrase Phrase;

	[FormerlySerializedAs("AutoSizeContainer")]
	public bool AutoSetWidth;

	public bool AutoSetHeight;

	public bool AutoSizeParent;

	public float MinWidth = 30f;

	public float MaxWidth = float.PositiveInfinity;

	public float MinHeight;

	public float MaxHeight = float.PositiveInfinity;

	private object[] localizationArguments;

	private static FastStringBuilder inputBuilder = new FastStringBuilder(2048);

	private bool invertedAlignment;

	public string LanguageToken => Token;

	public string LanguageEnglish => English;

	public void SetPhrase(Phrase phrase, params object[] args)
	{
		if (Application.isPlaying)
		{
			Phrase = phrase;
		}
		IsLocalized = true;
		Token = phrase.token;
		English = phrase.english;
		if (args != null && args.Length != 0)
		{
			SetPhraseArguments(args);
		}
		else
		{
			UpdateLocalizedText(forceEnglish: false);
		}
	}

	protected override void Awake()
	{
		((TextMeshProUGUI)this).Awake();
		UpdateLocalizedText(forceEnglish: false);
	}

	public void SetPhraseArguments(params object[] args)
	{
		localizationArguments = args;
		UpdateLocalizedText(forceEnglish: false);
	}

	public void SetText(string str)
	{
		SetText(str, localized: false);
	}

	public void SetText(string str, bool localized, bool forceRTLFormatting = false)
	{
		IsLocalized = localized;
		if (localized || forceRTLFormatting)
		{
			str = FormatLocalizedText(str, forceRTLFormatting);
			((TMP_Text)this).text = str;
			DoAutoSize();
			FormatAlignment();
		}
		else
		{
			((TMP_Text)this).text = str;
			DoAutoSize();
		}
	}

	public virtual void DoAutoSize()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Expected O, but got Unknown
		//IL_0098: Expected O, but got Unknown
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		//IL_0140: Expected O, but got Unknown
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Expected O, but got Unknown
		//IL_00c2: Expected O, but got Unknown
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Expected O, but got Unknown
		//IL_016a: Expected O, but got Unknown
		if ((Object)(object)((TMP_Text)this).font == (Object)null)
		{
			Debug.LogWarning((object)("null font: " + ((Object)((Component)this).gameObject).name), (Object)(object)((Component)this).gameObject);
			return;
		}
		if (AutoSetWidth)
		{
			RectTransform val = (RectTransform)((TMP_Text)this).transform;
			Vector2 preferredValues = ((TMP_Text)this).GetPreferredValues(((TMP_Text)this).text, float.PositiveInfinity, float.PositiveInfinity);
			preferredValues.x = Mathf.Clamp(preferredValues.x, MinWidth, MaxWidth);
			RectTransformEx.SetWidth(val, preferredValues.x + ((TMP_Text)this).m_currentFontAsset.normalSpacingOffset);
			RectTransformEx.DoAutoLayout(val);
			if (AutoSizeParent)
			{
				RectTransform val2 = (RectTransform)((TMP_Text)this).transform.parent;
				RectTransformEx.SetWidth(val2, preferredValues.x);
				RectTransformEx.DoAutoLayout(val2);
			}
		}
		if (AutoSetHeight)
		{
			RectTransform val3 = (RectTransform)((TMP_Text)this).transform;
			Rect rect = val3.rect;
			Vector2 preferredValues2 = ((TMP_Text)this).GetPreferredValues(((TMP_Text)this).text, ((Rect)(ref rect)).width - (((TMP_Text)this).m_margin.x + ((TMP_Text)this).m_margin.z), float.PositiveInfinity);
			preferredValues2.y = Mathf.Clamp(preferredValues2.y, MinHeight, MaxHeight);
			RectTransformEx.SetHeight(val3, preferredValues2.y);
			RectTransformEx.DoAutoLayout(val3);
			if (AutoSizeParent)
			{
				RectTransform val4 = (RectTransform)((TMP_Text)this).transform.parent;
				RectTransformEx.SetHeight(val4, preferredValues2.y);
				RectTransformEx.DoAutoLayout(val4);
			}
		}
	}

	public override void Rebuild(CanvasUpdate update)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)this == (Object)null))
		{
			((TextMeshProUGUI)this).Rebuild(update);
		}
	}

	private string GetLocalizedText(bool englishVersion)
	{
		if (Phrase != null)
		{
			if (localizationArguments != null)
			{
				return string.Format(Phrase.translated, localizationArguments);
			}
			return Phrase.translated;
		}
		string text = (englishVersion ? English : Translate.Get(Token, English));
		if (string.IsNullOrEmpty(text))
		{
			return string.Empty;
		}
		if (localizationArguments != null)
		{
			text = string.Format(text, localizationArguments);
		}
		return text;
	}

	private void UpdateLocalizedText(bool forceEnglish)
	{
		if (IsLocalized)
		{
			string localizedText = GetLocalizedText(forceEnglish);
			((TMP_Text)this).text = FormatLocalizedText(localizedText);
			DoAutoSize();
			FormatAlignment();
		}
	}

	public static void OnLanguageChanged()
	{
		RustText[] array = Resources.FindObjectsOfTypeAll<RustText>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateLocalizedText(forceEnglish: false);
		}
	}

	public string FormatLocalizedText(string str, bool force = false)
	{
		if (Translate.CurrentLanguageIsRTL() || force)
		{
			((TMP_Text)this).isRightToLeftText = TextUtils.ContainsRTLInput(str);
			if (((TMP_Text)this).isRightToLeftText)
			{
				inputBuilder.Clear();
				RTLSupport.FixRTL(str, inputBuilder, false, true, true);
				inputBuilder.Reverse();
				str = ((object)inputBuilder).ToString();
				((TMP_Text)this).text = str;
			}
			return str;
		}
		((TMP_Text)this).isRightToLeftText = false;
		return str;
	}

	private void FormatAlignment()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Invalid comparison between Unknown and I4
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Invalid comparison between Unknown and I4
		if (Translate.CurrentLanguageIsRTL() && TextUtils.ContainsRTLInput(((TMP_Text)this).text))
		{
			if ((((TMP_Text)this).textInfo.lineCount >= 3 && (int)GetHorizontalAlignment() == 1) || (int)GetHorizontalAlignment() == 8)
			{
				SetHorizontalAlignment((_HorizontalAlignmentOptions)4);
				invertedAlignment = true;
			}
		}
		else if (invertedAlignment)
		{
			SetHorizontalAlignment((_HorizontalAlignmentOptions)1);
			invertedAlignment = false;
		}
	}

	public _HorizontalAlignmentOptions GetHorizontalAlignment()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return (_HorizontalAlignmentOptions)(((TMP_Text)this).alignment & 0x3F);
	}

	public _VerticalAlignmentOptions GetVerticalAligment()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return (_VerticalAlignmentOptions)(((TMP_Text)this).alignment & 0xFF00);
	}

	public void SetHorizontalAlignment(_HorizontalAlignmentOptions option)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		((TMP_Text)this).alignment = (TextAlignmentOptions)(option | GetVerticalAligment());
	}

	public void SetVerticalAlignment(_VerticalAlignmentOptions option)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		((TMP_Text)this).alignment = (TextAlignmentOptions)(option | GetHorizontalAlignment());
	}
}


using System;
using System.Collections;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RustToggle : RustControl, IPointerDownHandler, IEventSystemHandler
{
	[Serializable]
	public class ChangedEvent : UnityEvent<bool>
	{
	}

	public StyleAsset StyleOff;

	public Image Handle;

	public RustText TextOn;

	public RustText TextOff;

	public bool Value;

	public float SliderWidth = 0.3f;

	public ChangedEvent OnChanged;

	private Coroutine anim;

	public override StyleAsset Styles
	{
		get
		{
			if (!Value)
			{
				return StyleOff;
			}
			return base.Styles;
		}
	}

	public void SetValue(bool value)
	{
		if (value != Value)
		{
			Value = value;
			ApplyStyles();
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		Value = !Value;
		((UnityEvent<bool>)OnChanged)?.Invoke(Value);
		if (anim != null)
		{
			((MonoBehaviour)this).StopCoroutine(anim);
		}
		anim = ((MonoBehaviour)this).StartCoroutine(AnimateTo());
	}

	private IEnumerator AnimateTo()
	{
		Vector2 handleMin = new Vector2(((Graphic)Handle).rectTransform.anchorMin.x, (!Value) ? 0f : (1f - SliderWidth));
		Vector2 handleMax = new Vector2(((Graphic)Handle).rectTransform.anchorMax.x, (!Value) ? SliderWidth : 1f);
		float animTime = 0.15f;
		float time = 0f;
		Image bg = ((Component)this).GetComponent<Image>();
		for (; time < animTime; time += Time.unscaledDeltaTime)
		{
			StyleColorSet currentStyleCollection = CurrentStyleCollection;
			float num = time / animTime;
			((Graphic)TextOn).color = Color.Lerp(((Graphic)TextOn).color, ColorEx.WithAlpha(currentStyleCollection.Fg, (float)(Value ? 1 : 0)), num);
			((Graphic)TextOff).color = Color.Lerp(((Graphic)TextOff).color, ColorEx.WithAlpha(currentStyleCollection.Fg, (float)((!Value) ? 1 : 0)), num);
			((Graphic)Handle).color = Color.Lerp(((Graphic)Handle).color, currentStyleCollection.Fg, num);
			((Graphic)bg).color = Color.Lerp(((Graphic)bg).color, currentStyleCollection.Bg, num);
			Vector2 anchorMax = ((Graphic)Handle).rectTransform.anchorMax;
			anchorMax.x = Mathf.Lerp(handleMax.x, handleMax.y, num * (2f - num));
			((Graphic)Handle).rectTransform.anchorMax = anchorMax;
			Vector2 anchorMin = ((Graphic)Handle).rectTransform.anchorMin;
			anchorMin.x = Mathf.Lerp(handleMin.x, handleMin.y, num * (2f - num));
			((Graphic)Handle).rectTransform.anchorMin = anchorMin;
			yield return null;
		}
		anim = null;
		ApplyStyles();
	}

	public override void ApplyStyles()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		if (anim == null && !((Object)(object)Styles == (Object)null))
		{
			Vector2 anchorMin = ((Graphic)Handle).rectTransform.anchorMin;
			anchorMin.x = ((!Value) ? 0f : (1f - SliderWidth));
			((Graphic)Handle).rectTransform.anchorMin = anchorMin;
			Vector2 anchorMax = ((Graphic)Handle).rectTransform.anchorMax;
			anchorMax.x = ((!Value) ? SliderWidth : 1f);
			((Graphic)Handle).rectTransform.anchorMax = anchorMax;
			StyleColorSet currentStyleCollection = CurrentStyleCollection;
			((Graphic)((Component)this).GetComponent<Image>()).color = currentStyleCollection.Bg;
			((TMP_Text)TextOn).rectTransform.anchorMax = Vector2Ex.X(((TMP_Text)TextOn).rectTransform.anchorMax, 1f - SliderWidth);
			((TMP_Text)TextOff).rectTransform.anchorMin = Vector2Ex.X(((TMP_Text)TextOn).rectTransform.anchorMin, SliderWidth);
			((Graphic)TextOn).color = ColorEx.WithAlpha(currentStyleCollection.Fg, (float)(Value ? 1 : 0));
			((Graphic)TextOff).color = ColorEx.WithAlpha(currentStyleCollection.Fg, (float)((!Value) ? 1 : 0));
			((Graphic)Handle).color = currentStyleCollection.Fg;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RustWrapper : RustControl
{
	public RustText Text;

	public RectTransform Canvas;

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyStyle(s);
		if ((Object)(object)Text != (Object)null)
		{
			((Graphic)Text).color = s.Fg;
		}
		Image component = ((Component)this).GetComponent<Image>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Graphic)component).color = s.Bg;
		}
	}

	public void Add(UIBehaviour ui)
	{
		((Component)ui).transform.SetParent(((Component)Canvas).transform, false);
		if (ui is RustControl rustControl)
		{
			rustControl.FormField = this;
		}
	}

	public void AddFlex()
	{
		Add((UIBehaviour)(object)Make.Flex());
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class TabControl : RustControl
{
	public RectTransform TabContainer;

	public RectTransform PanelContainer;

	public RustButton ButtonControl;

	public float InnerPadding;

	public bool AllowCloseAll;

	public Image Background;

	public Image Foreground;

	public RustLayout Panel(string name)
	{
		Transform obj = ((Transform)PanelContainer).Find(name);
		if (obj == null)
		{
			return null;
		}
		return ((Component)obj).GetComponent<RustLayout>();
	}

	public RustButton Button(string name)
	{
		Transform obj = ((Transform)TabContainer).Find(name);
		if (obj == null)
		{
			return null;
		}
		return ((Component)obj).GetComponent<RustButton>();
	}

	public void AddTab(string name, Phrase buttontext = null, Icons icon = Icons.ExclamationSquare)
	{
		bool flag = ((Transform)PanelContainer).childCount == 0;
		GameObject obj = Object.Instantiate<GameObject>(((Component)ButtonControl).gameObject);
		((Object)obj).name = name;
		RustButton component = obj.GetComponent<RustButton>();
		((UIBehaviour)(object)component).SetParent((Transform)(object)TabContainer);
		component.Text.AutoSizeParent = true;
		component.Text.AutoSetWidth = true;
		component.IsToggle = true;
		component.UnpressSiblings = true;
		component.PreventToggleOff = !AllowCloseAll;
		component.TabPanelTarget = (Transform)(object)PanelContainer;
		component.Icon.Icon = icon;
		if (buttontext == null)
		{
			((TMP_Text)component.Text).text = name;
			component.Text.DoAutoSize();
		}
		else
		{
			component.Text.SetPhrase(buttontext);
		}
		if (flag && !AllowCloseAll)
		{
			component.Toggle(v: true);
		}
		RustLayout rustLayout = Make.Container.Vertical();
		((Object)rustLayout).name = name;
		((UIBehaviour)(object)rustLayout).SetParent((Transform)(object)PanelContainer);
		Transform transform = ((Component)rustLayout).transform;
		((RectTransform)(object)((transform is RectTransform) ? transform : null)).Fill(InnerPadding, InnerPadding, InnerPadding, InnerPadding);
		((Component)rustLayout).gameObject.SetActive(flag && !AllowCloseAll);
		LayoutRebuilder.MarkLayoutForRebuild(TabContainer);
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyStyle(s);
		if (Object.op_Implicit((Object)(object)Background))
		{
			((Graphic)Background).color = s.Bg;
		}
		if (Object.op_Implicit((Object)(object)Foreground))
		{
			((Graphic)Foreground).color = s.Fg;
		}
	}
}


using System;
using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[AddComponentMenu("Rust/UI/Timeline")]
public class Timeline : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
{
	[Serializable]
	public class ScrubEvent : UnityEvent<float>
	{
	}

	public int StartTime;

	public int EndTime;

	public int CurrentPosition;

	public TimeRuler TimeRuler;

	public RectTransform IndicatorCurrent;

	public UnityEvent OnStartScrub;

	public UnityEvent OnEndScrub;

	public ScrubEvent OnScrubToTime;

	public List<TimelineMarker> Markers = new List<TimelineMarker>();

	public TimelineMarker SelectedMarker { get; set; }

	internal void SelectMarker(TimelineMarker marker)
	{
		if ((Object)(object)SelectedMarker == (Object)(object)marker)
		{
			return;
		}
		SelectedMarker = marker;
		foreach (TimelineMarker marker2 in Markers)
		{
			marker2.ApplyStyles();
		}
		TimelineMarker selectedMarker = SelectedMarker;
		if (selectedMarker != null)
		{
			Transform transform = ((Component)selectedMarker).transform;
			if (transform != null)
			{
				transform.SetAsLastSibling();
			}
		}
		RectTransform indicatorCurrent = IndicatorCurrent;
		if (indicatorCurrent != null)
		{
			((Transform)indicatorCurrent).SetAsLastSibling();
		}
	}

	internal void DragMarker(TimelineMarker marker, PointerEventData eventData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(base.rectTransform, eventData.position, eventData.pressEventCamera, ref val))
		{
			Vector2 val2 = val;
			Rect rect = base.rectTransform.rect;
			val = val2 + ((Rect)(ref rect)).size * base.rectTransform.pivot;
			int time = GetTime(val.x);
			marker.SetTime(time);
			marker.Position(this);
			if ((Object)(object)marker == (Object)(object)SelectedMarker)
			{
				Scrubbed(marker.CurrentPosition);
			}
		}
	}

	internal void DeleteMarker(TimelineMarker timelineMarker)
	{
		Markers.Remove(timelineMarker);
		Object.Destroy((Object)(object)((Component)timelineMarker).gameObject);
	}

	protected override void Awake()
	{
		Markers.Clear();
		Markers.AddRange(((Component)this).GetComponentsInChildren<TimelineMarker>());
		Rebuild();
	}

	public void Rebuild()
	{
		TimeRuler.StartTime = StartTime;
		TimeRuler.EndTime = EndTime;
		TimeRuler.Rebuild();
		foreach (TimelineMarker marker in Markers)
		{
			marker.Position(this);
		}
	}

	public void AddMarker(TimelineMarker marker)
	{
		Markers.Add(marker);
		((UIBehaviour)(object)marker).SetParent((UIBehaviour)(object)this);
		marker.Position(this);
	}

	public void SetCurrentPosition(int pos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		CurrentPosition = pos;
		float x = GetX(pos);
		IndicatorCurrent.offsetMin = Vector2Ex.WithX(IndicatorCurrent.offsetMin, x);
		IndicatorCurrent.offsetMax = Vector2Ex.WithX(IndicatorCurrent.offsetMax, x + 1f);
	}

	public float GetX(int time)
	{
		return (float)time / (float)EndTime * base.rectTransform.GetWidth();
	}

	public int GetTime(float x)
	{
		return Mathf.Clamp(Mathf.RoundToInt(x / base.rectTransform.GetWidth() * (float)EndTime), StartTime, EndTime);
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		OnDrag(eventData);
		OnStartScrub.Invoke();
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		OnDrag(eventData);
		OnEndScrub.Invoke();
	}

	public void Scrubbed(int time)
	{
		time = Mathf.Clamp(time, StartTime, EndTime);
		((UnityEvent<float>)OnScrubToTime).Invoke((float)time);
	}

	public void OnDrag(PointerEventData eventData)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		SelectMarker(null);
		Vector2 val = default(Vector2);
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(base.rectTransform, eventData.position, eventData.pressEventCamera, ref val))
		{
			Vector2 val2 = val;
			Rect rect = base.rectTransform.rect;
			val = val2 + ((Rect)(ref rect)).size * base.rectTransform.pivot;
			Scrubbed(GetTime(val.x));
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class TimelineMarker : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler
{
	public int CurrentPosition;

	public Image Background;

	private Timeline Parent;

	private bool hasDragged;

	public override bool IsPressed
	{
		get
		{
			if (!base.IsPressed)
			{
				if ((Object)(object)Parent != (Object)null)
				{
					return (Object)(object)Parent.SelectedMarker == (Object)(object)this;
				}
				return false;
			}
			return true;
		}
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		hasDragged = false;
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		if (!hasDragged)
		{
			SelectMarker();
		}
	}

	public virtual void SelectMarker()
	{
		Parent?.SelectMarker(this);
	}

	public void OnDrag(PointerEventData eventData)
	{
		hasDragged = true;
		Parent?.DragMarker(this, eventData);
	}

	internal void Position(Timeline timeline)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float x = timeline.GetX(CurrentPosition);
		base.rectTransform.anchoredPosition = Vector2Ex.WithX(base.rectTransform.anchoredPosition, x);
		Parent = timeline;
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		base.ApplyStyle(s);
		((Graphic)Background).color = s.Bg;
	}

	public virtual void SetTime(int time)
	{
		CurrentPosition = time;
	}

	public void Delete()
	{
		Parent.DeleteMarker(this);
	}
}


using Facepunch;
using Rust.UI;
using Rust.UI.Renderer;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/TimeRuler")]
public class TimeRuler : RustControl
{
	public int StartTime;

	public int EndTime = 1000;

	public RustText TextPrefab;

	public TickRenderer TickRenderer;

	public void Rebuild()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Invalid comparison between Unknown and I4
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		for (int num = ((Component)this).transform.childCount; num > 0; num--)
		{
			Transform child = ((Component)this).transform.GetChild(num - 1);
			if ((int)((Object)((Component)child).gameObject).hideFlags == 61)
			{
				Object.DestroyImmediate((Object)(object)((Component)child).gameObject);
			}
		}
		int num2 = EndTime - StartTime;
		int num3 = 100;
		if (num2 > 1500)
		{
			num3 = 1000;
		}
		if (num2 > 10000)
		{
			num3 = 10000;
		}
		if (num2 > 100000)
		{
			num3 = 100000;
		}
		if (num2 < 1000)
		{
			num3 = 100;
		}
		if (num2 < 150)
		{
			num3 = 10;
		}
		if ((Object)(object)TextPrefab == (Object)null)
		{
			return;
		}
		int num4 = Mathf.FloorToInt((float)(StartTime / num3 - 1)) * num3;
		int num5 = Mathf.CeilToInt((float)(EndTime / num3 + 2)) * num3;
		TickRenderer.Ticks.Clear();
		_ = base.rectTransform.GetWidth() / (float)num2;
		for (int i = num4; i < num5; i += num3)
		{
			float num6 = TimeToPos(i);
			RustText rustText = ComponentExtensions.Duplicate<RustText>(TextPrefab);
			((TMP_Text)rustText).text = $"{i}";
			((Object)((Component)rustText).gameObject).hideFlags = (HideFlags)61;
			((TMP_Text)rustText).rectTransform.offsetMin = new Vector2(num6, -1f);
			((TMP_Text)rustText).rectTransform.offsetMax = new Vector2(num6 + 1f, 0f);
			((UIBehaviour)(object)rustText).SetParent(((Component)this).transform);
			TickRenderer.Ticks.Add(new TickRenderer.Tick
			{
				Pos = num6,
				Color = Color.white,
				Height = 1f
			});
			for (int j = 1; j < 10; j++)
			{
				num6 = TimeToPos(i + j * (int)((float)num3 / 10f));
				TickRenderer.Ticks.Add(new TickRenderer.Tick
				{
					Pos = num6,
					Color = new Color(1f, 1f, 1f, 0.2f),
					Height = 0.8f
				});
			}
		}
		((Graphic)TickRenderer).SetVerticesDirty();
	}

	public float TimeToPos(int time)
	{
		return (float)(time - StartTime) / (float)(EndTime - StartTime) * base.rectTransform.GetWidth();
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using UnityEngine.Video;

public class Video : RustControl
{
	public RawImage VideoCanvas;

	public VideoPlayer VideoPlayer;

	public CanvasGroup CanvasGroup;

	[Range(0f, 5f)]
	public float FadeIn;

	private uint textureWidth;

	private uint textureHeight;

	private Vector2 playerSize;

	protected override void Awake()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		((UIBehaviour)this).Awake();
		VideoPlayer.errorReceived += new ErrorEventHandler(VideoPlayer_errorReceived);
	}

	private void VideoPlayer_errorReceived(VideoPlayer source, string message)
	{
		Debug.Log((object)("Video Error: \"" + message + "\""));
	}

	public void PlayUrl(string video)
	{
		VideoPlayer.Stop();
		VideoPlayer.url = video;
		VideoPlayer.Play();
		CanvasGroup.alpha = 0f;
		textureWidth = 0u;
		textureHeight = 0u;
	}

	public void LateUpdate()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)VideoPlayer.texture == (Object)null)
		{
			CanvasGroup.alpha = 0f;
			textureWidth = 0u;
			textureHeight = 0u;
			VideoCanvas.texture = null;
		}
		else if ((textureWidth != VideoPlayer.width || textureHeight != VideoPlayer.height || !(playerSize == base.rectTransform.GetSize())) && VideoPlayer.isPrepared && VideoPlayer.frame >= 0)
		{
			VideoCanvas.texture = VideoPlayer.texture;
			textureWidth = VideoPlayer.width;
			textureHeight = VideoPlayer.height;
			Cover();
			if (FadeIn > 0f)
			{
				CanvasGroup.alpha = 0f;
				LeanTween.alphaCanvas(CanvasGroup, 1f, FadeIn);
			}
			else
			{
				CanvasGroup.alpha = 1f;
			}
		}
	}

	private void Cover()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)VideoCanvas).transform;
		RectTransform trans = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		Vector2 size = base.rectTransform.GetSize();
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)VideoPlayer.width, (float)VideoPlayer.height);
		float num = size.x / size.y;
		float num2 = val.x / val.y;
		playerSize = size;
		if (num == num2)
		{
			trans.SetSize(new Vector2(size.x, size.y));
		}
		if (num > num2)
		{
			trans.SetSize(new Vector2(size.x, size.x / num2));
		}
		if (num < num2)
		{
			trans.SetSize(new Vector2(size.y * num2, size.y));
		}
	}

	public void Stop()
	{
		VideoPlayer.Stop();
		VideoCanvas.texture = null;
		textureWidth = 0u;
		textureHeight = 0u;
		CanvasGroup.alpha = 0f;
	}
}


using System.Collections;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.UI;

public class HttpImage : MonoBehaviour
{
	public static Dictionary<string, UnityWebRequest> RequestCache = new Dictionary<string, UnityWebRequest>();

	public static Dictionary<string, (Texture2D, Sprite)> TextureCache = new Dictionary<string, (Texture2D, Sprite)>();

	public Texture2D LoadingImage;

	public Texture2D MissingImage;

	public string Url = "";

	public bool AutosizeHeight;

	[Tooltip("Fill the RectTransform with the image without skewing when rendering in a RawImage and AutosizeHeight is disabled.")]
	public bool UseCoverFill;

	public bool GenerateMipmaps = true;

	public float MaxWidth;

	public float MaxHeight;

	public bool AllowDisablingImage = true;

	public RawImage rawImage;

	private Image image;

	private Sprite loadingSprite;

	private Sprite missingSprite;

	private bool didLoad;

	public bool IsLoading { get; private set; }

	private void Init()
	{
		rawImage = ((Component)this).GetComponent<RawImage>();
		image = ((Component)this).GetComponent<Image>();
		if ((Object)(object)LoadingImage != (Object)null)
		{
			loadingSprite = CreateSprite(LoadingImage);
		}
		if ((Object)(object)MissingImage != (Object)null)
		{
			missingSprite = CreateSprite(MissingImage);
		}
		SetImageEnabled(enabled: false);
	}

	private void Start()
	{
		if (!didLoad)
		{
			Init();
			if (Url != string.Empty)
			{
				string url = Url;
				Url = string.Empty;
				Load(url);
			}
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)loadingSprite != (Object)null)
		{
			Object.Destroy((Object)(object)loadingSprite);
		}
		if ((Object)(object)missingSprite != (Object)null)
		{
			Object.Destroy((Object)(object)missingSprite);
		}
	}

	public bool Load(string url)
	{
		if (string.IsNullOrEmpty(url))
		{
			return false;
		}
		if (Url == url)
		{
			return false;
		}
		if ((Object)(object)rawImage == (Object)null && (Object)(object)image == (Object)null)
		{
			Init();
		}
		IsLoading = true;
		SetLoadingImage();
		Url = url;
		didLoad = true;
		if (TextureCache.TryGetValue(url, out var value))
		{
			UpdateImageTexture(value);
			return false;
		}
		if (RequestCache.ContainsKey(url))
		{
			SetImageEnabled(enabled: false);
			((MonoBehaviour)Global.Runner).StartCoroutine(WaitForLoad(url));
			return false;
		}
		SetImageEnabled(enabled: false);
		((MonoBehaviour)Global.Runner).StartCoroutine(StartAndWaitForLoad(url));
		return true;
	}

	public void Load(Sprite sprite)
	{
		if ((Object)(object)rawImage == (Object)null && (Object)(object)image == (Object)null)
		{
			Init();
		}
		Url = null;
		didLoad = true;
		UpdateImageTexture((sprite.texture, sprite));
	}

	private IEnumerator WaitForLoad(string url)
	{
		while (!TextureCache.ContainsKey(url) && url == Url)
		{
			yield return null;
		}
		if (Object.op_Implicit((Object)(object)this) && url == Url && ((Object)(object)rawImage != (Object)null || (Object)(object)image != (Object)null))
		{
			UpdateImageTexture(TextureCache[url]);
		}
	}

	private void UpdateImageTexture((Texture2D, Sprite) tex)
	{
		if (!((Object)(object)tex.Item1 == (Object)null) && !((Object)(object)tex.Item2 == (Object)null) && Object.op_Implicit((Object)(object)this) && ((Object)(object)rawImage != (Object)null || (Object)(object)image != (Object)null))
		{
			if ((Object)(object)rawImage != (Object)null)
			{
				rawImage.texture = (Texture)(object)tex.Item1;
			}
			if ((Object)(object)image != (Object)null)
			{
				image.sprite = tex.Item2;
			}
			SetImageEnabled(enabled: true);
			AutosizeForTexture(tex.Item1);
		}
	}

	public void SetMissingImage()
	{
		UpdateImageTexture((MissingImage, missingSprite));
		Url = "";
	}

	public void SetLoadingImage()
	{
		UpdateImageTexture((LoadingImage, loadingSprite));
		Url = "";
	}

	private IEnumerator StartAndWaitForLoad(string url)
	{
		UnityWebRequest request = new UnityWebRequest(url);
		request.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();
		RequestCache.Add(url, request);
		yield return request.SendWebRequest();
		RequestCache.Remove(url);
		Texture2D val = null;
		if (request.isDone && !request.isHttpError && !request.isNetworkError)
		{
			val = (GenerateMipmaps ? new Texture2D(16, 16) : new Texture2D(16, 16, (TextureFormat)5, false));
			((Object)val).name = url;
			((Texture)val).wrapMode = (TextureWrapMode)1;
			if (!ImageConversion.LoadImage(val, request.downloadHandler.data, true))
			{
				Object.DestroyImmediate((Object)(object)val);
				val = null;
			}
			else if ((MaxWidth > 0f && (float)((Texture)val).width > MaxWidth) || (MaxHeight > 0f && (float)((Texture)val).height > MaxHeight))
			{
				Debug.Log((object)("Texture from " + url + " was too big, ignoring"));
				Object.DestroyImmediate((Object)(object)val);
				val = null;
			}
		}
		if ((Object)(object)val == (Object)null)
		{
			if ((Object)(object)MissingImage != (Object)null)
			{
				val = MissingImage;
			}
			if ((Object)(object)val == (Object)null)
			{
				val = Texture2D.blackTexture;
			}
		}
		Sprite item = CreateSprite(val);
		(Texture2D, Sprite) tuple = (val, item);
		TextureCache.Add(url, tuple);
		request.Dispose();
		if (Object.op_Implicit((Object)(object)this) && url == Url && ((Object)(object)rawImage != (Object)null || (Object)(object)image != (Object)null))
		{
			UpdateImageTexture(tuple);
			AutosizeForTexture(val);
		}
	}

	private void AutosizeForTexture(Texture2D texture)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		if (AutosizeHeight)
		{
			float num = (float)((Texture)texture).width / (float)((Texture)texture).height;
			if ((Object)(object)rawImage != (Object)null)
			{
				((Graphic)rawImage).rectTransform.sizeDelta = new Vector2(((Graphic)rawImage).rectTransform.sizeDelta.x, ((Graphic)rawImage).rectTransform.sizeDelta.x / num);
			}
			if ((Object)(object)image != (Object)null)
			{
				((Graphic)image).rectTransform.sizeDelta = new Vector2(((Graphic)image).rectTransform.sizeDelta.x, ((Graphic)image).rectTransform.sizeDelta.x / num);
			}
			SetImageEnabled(enabled: true);
		}
		UpdateCoverFill();
	}

	private void UpdateCoverFill()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		if (UseCoverFill && !((Object)(object)rawImage == (Object)null))
		{
			Texture texture = rawImage.texture;
			Rect uvRect = ((Graphic)rawImage).GetPixelAdjustedRect();
			Vector2 size = ((Rect)(ref uvRect)).size;
			Vector2 val = default(Vector2);
			((Vector2)(ref val))..ctor((float)texture.width, (float)texture.height);
			float num = size.x / size.y;
			float num2 = val.x / val.y;
			float num3 = ((num >= num2) ? (size.x / val.x) : (size.y / val.y));
			float num4 = val.x * num3;
			float num5 = val.y * num3;
			RawImage obj = rawImage;
			uvRect = default(Rect);
			((Rect)(ref uvRect)).x = (num4 - size.x) / 2f / num4;
			((Rect)(ref uvRect)).y = (num5 - size.y) / 2f / num5;
			((Rect)(ref uvRect)).width = size.x / num4;
			((Rect)(ref uvRect)).height = size.y / num5;
			obj.uvRect = uvRect;
		}
	}

	private void SetImageEnabled(bool enabled)
	{
		if (AllowDisablingImage)
		{
			if ((Object)(object)rawImage != (Object)null)
			{
				((Behaviour)rawImage).enabled = enabled;
			}
			if ((Object)(object)image != (Object)null)
			{
				((Behaviour)image).enabled = enabled;
			}
			if (enabled)
			{
				IsLoading = false;
			}
		}
	}

	private void OnRectTransformDimensionsChange()
	{
		UpdateCoverFill();
	}

	private static Sprite CreateSprite(Texture2D texture)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		return Sprite.Create(texture, new Rect(Vector2.zero, new Vector2((float)((Texture)texture).width, (float)((Texture)texture).height)), new Vector2(0.5f, 0.5f));
	}
}


public enum Icons
{
	None = 0,
	Abacus = 63040,
	Acorn = 63150,
	Ad = 63041,
	AddressBook = 62137,
	AddressCard = 62139,
	Adjust = 61506,
	AirFreshener = 62928,
	AlarmClock = 62286,
	AlarmExclamation = 63555,
	AlarmPlus = 63556,
	AlarmSnooze = 63557,
	Album = 63647,
	AlbumCollection = 63648,
	Alicorn = 63152,
	AlignCenter = 61495,
	AlignJustify = 61497,
	AlignLeft = 61494,
	AlignRight = 61496,
	AlignSlash = 63558,
	Allergies = 62561,
	Ambulance = 61689,
	AmericanSignLanguageInterpreting = 62115,
	AmpGuitar = 63649,
	Analytics = 63043,
	Anchor = 61757,
	Angel = 63353,
	AngleDoubleDown = 61699,
	AngleDoubleLeft = 61696,
	AngleDoubleRight = 61697,
	AngleDoubleUp = 61698,
	AngleDown = 61703,
	AngleLeft = 61700,
	AngleRight = 61701,
	AngleUp = 61702,
	Angry = 62806,
	Ankh = 63044,
	AppleAlt = 62929,
	AppleCrate = 63153,
	Archive = 61831,
	Archway = 62807,
	ArrowAltCircleDown = 62296,
	ArrowAltCircleLeft = 62297,
	ArrowAltCircleRight = 62298,
	ArrowAltCircleUp = 62299,
	ArrowAltDown = 62292,
	ArrowAltFromBottom = 62278,
	ArrowAltFromLeft = 62279,
	ArrowAltFromRight = 62280,
	ArrowAltFromTop = 62281,
	ArrowAltLeft = 62293,
	ArrowAltRight = 62294,
	ArrowAltSquareDown = 62288,
	ArrowAltSquareLeft = 62289,
	ArrowAltSquareRight = 62290,
	ArrowAltSquareUp = 62291,
	ArrowAltToBottom = 62282,
	ArrowAltToLeft = 62283,
	ArrowAltToRight = 62284,
	ArrowAltToTop = 62285,
	ArrowAltUp = 62295,
	ArrowCircleDown = 61611,
	ArrowCircleLeft = 61608,
	ArrowCircleRight = 61609,
	ArrowCircleUp = 61610,
	ArrowDown = 61539,
	ArrowFromBottom = 62274,
	ArrowFromLeft = 62275,
	ArrowFromRight = 62276,
	ArrowFromTop = 62277,
	ArrowLeft = 61536,
	ArrowRight = 61537,
	ArrowSquareDown = 62265,
	ArrowSquareLeft = 62266,
	ArrowSquareRight = 62267,
	ArrowSquareUp = 62268,
	ArrowToBottom = 62269,
	ArrowToLeft = 62270,
	ArrowToRight = 62272,
	ArrowToTop = 62273,
	ArrowUp = 61538,
	Arrows = 61511,
	ArrowsAlt = 61618,
	ArrowsAltH = 62263,
	ArrowsAltV = 62264,
	ArrowsH = 61566,
	ArrowsV = 61565,
	AssistiveListeningSystems = 62114,
	Asterisk = 61545,
	At = 61946,
	Atlas = 62808,
	Atom = 62930,
	AtomAlt = 62931,
	AudioDescription = 62110,
	Award = 62809,
	Axe = 63154,
	AxeBattle = 63155,
	Baby = 63356,
	BabyCarriage = 63357,
	Backpack = 62932,
	Backspace = 62810,
	Backward = 61514,
	Bacon = 63461,
	Badge = 62261,
	BadgeCheck = 62262,
	BadgeDollar = 63045,
	BadgePercent = 63046,
	BadgeSheriff = 63650,
	BadgerHoney = 63156,
	BagsShopping = 63559,
	BalanceScale = 62030,
	BalanceScaleLeft = 62741,
	BalanceScaleRight = 62742,
	BallPile = 63358,
	Ballot = 63282,
	BallotCheck = 63283,
	Ban = 61534,
	BandAid = 62562,
	Banjo = 63651,
	Barcode = 61482,
	BarcodeAlt = 62563,
	BarcodeRead = 62564,
	BarcodeScan = 62565,
	Bars = 61641,
	Baseball = 62514,
	BaseballBall = 62515,
	BasketballBall = 62516,
	BasketballHoop = 62517,
	Bat = 63157,
	Bath = 62157,
	BatteryBolt = 62326,
	BatteryEmpty = 62020,
	BatteryFull = 62016,
	BatteryHalf = 62018,
	BatteryQuarter = 62019,
	BatterySlash = 62327,
	BatteryThreeQuarters = 62017,
	Bed = 62006,
	Beer = 61692,
	Bell = 61683,
	BellExclamation = 63560,
	BellPlus = 63561,
	BellSchool = 62933,
	BellSchoolSlash = 62934,
	BellSlash = 61942,
	Bells = 63359,
	Betamax = 63652,
	BezierCurve = 62811,
	Bible = 63047,
	Bicycle = 61958,
	Biking = 63562,
	BikingMountain = 63563,
	Binoculars = 61925,
	Biohazard = 63360,
	BirthdayCake = 61949,
	Blanket = 62616,
	Blender = 62743,
	BlenderPhone = 63158,
	Blind = 62109,
	Blog = 63361,
	Bold = 61490,
	Bolt = 61671,
	Bomb = 61922,
	Bone = 62935,
	BoneBreak = 62936,
	Bong = 62812,
	Book = 61485,
	BookAlt = 62937,
	BookDead = 63159,
	BookHeart = 62617,
	BookMedical = 63462,
	BookOpen = 62744,
	BookReader = 62938,
	BookSpells = 63160,
	BookUser = 63463,
	Bookmark = 61486,
	Books = 62939,
	BooksMedical = 63464,
	Boombox = 63653,
	Boot = 63362,
	BoothCurtain = 63284,
	BorderAll = 63564,
	BorderBottom = 63565,
	BorderCenterH = 63644,
	BorderCenterV = 63645,
	BorderInner = 63566,
	BorderLeft = 63567,
	BorderNone = 63568,
	BorderOuter = 63569,
	BorderRight = 63570,
	BorderStyle = 63571,
	BorderStyleAlt = 63572,
	BorderTop = 63573,
	BowArrow = 63161,
	BowlingBall = 62518,
	BowlingPins = 62519,
	Box = 62566,
	BoxAlt = 62618,
	BoxBallot = 63285,
	BoxCheck = 62567,
	BoxFragile = 62619,
	BoxFull = 62620,
	BoxHeart = 62621,
	BoxOpen = 62622,
	BoxUp = 62623,
	BoxUsd = 62624,
	Boxes = 62568,
	BoxesAlt = 62625,
	BoxingGlove = 62520,
	Brackets = 63465,
	BracketsCurly = 63466,
	Braille = 62113,
	Brain = 62940,
	BreadLoaf = 63467,
	BreadSlice = 63468,
	Briefcase = 61617,
	BriefcaseMedical = 62569,
	BringForward = 63574,
	BringFront = 63575,
	BroadcastTower = 62745,
	Broom = 62746,
	Browser = 62334,
	Brush = 62813,
	Bug = 61832,
	Building = 61869,
	Bullhorn = 61601,
	Bullseye = 61760,
	BullseyeArrow = 63048,
	BullseyePointer = 63049,
	BurgerSoda = 63576,
	Burn = 62570,
	Burrito = 63469,
	Bus = 61959,
	BusAlt = 62814,
	BusSchool = 62941,
	BusinessTime = 63050,
	CabinetFiling = 63051,
	Cactus = 63655,
	Calculator = 61932,
	CalculatorAlt = 63052,
	Calendar = 61747,
	CalendarAlt = 61555,
	CalendarCheck = 62068,
	CalendarDay = 63363,
	CalendarEdit = 62259,
	CalendarExclamation = 62260,
	CalendarMinus = 62066,
	CalendarPlus = 62065,
	CalendarStar = 63286,
	CalendarTimes = 62067,
	CalendarWeek = 63364,
	Camcorder = 63656,
	Camera = 61488,
	CameraAlt = 62258,
	CameraMovie = 63657,
	CameraPolaroid = 63658,
	CameraRetro = 61571,
	Campfire = 63162,
	Campground = 63163,
	CandleHolder = 63164,
	CandyCane = 63366,
	CandyCorn = 63165,
	Cannabis = 62815,
	Capsules = 62571,
	Car = 61881,
	CarAlt = 62942,
	CarBattery = 62943,
	CarBuilding = 63577,
	CarBump = 62944,
	CarBus = 63578,
	CarCrash = 62945,
	CarGarage = 62946,
	CarMechanic = 62947,
	CarSide = 62948,
	CarTilt = 62949,
	CarWash = 62950,
	CaretCircleDown = 62253,
	CaretCircleLeft = 62254,
	CaretCircleRight = 62256,
	CaretCircleUp = 62257,
	CaretDown = 61655,
	CaretLeft = 61657,
	CaretRight = 61658,
	CaretSquareDown = 61776,
	CaretSquareLeft = 61841,
	CaretSquareRight = 61778,
	CaretSquareUp = 61777,
	CaretUp = 61656,
	Carrot = 63367,
	Cars = 63579,
	CartArrowDown = 61976,
	CartPlus = 61975,
	CashRegister = 63368,
	CassetteTape = 63659,
	Cat = 63166,
	Cauldron = 63167,
	Cctv = 63660,
	Certificate = 61603,
	Chair = 63168,
	ChairOffice = 63169,
	Chalkboard = 62747,
	ChalkboardTeacher = 62748,
	ChargingStation = 62951,
	ChartArea = 61950,
	ChartBar = 61568,
	ChartLine = 61953,
	ChartLineDown = 63053,
	ChartNetwork = 63370,
	ChartPie = 61952,
	ChartPieAlt = 63054,
	ChartScatter = 63470,
	Check = 61452,
	CheckCircle = 61528,
	CheckDouble = 62816,
	CheckSquare = 61770,
	Cheese = 63471,
	CheeseSwiss = 63472,
	Cheeseburger = 63473,
	Chess = 62521,
	ChessBishop = 62522,
	ChessBishopAlt = 62523,
	ChessBoard = 62524,
	ChessClock = 62525,
	ChessClockAlt = 62526,
	ChessKing = 62527,
	ChessKingAlt = 62528,
	ChessKnight = 62529,
	ChessKnightAlt = 62530,
	ChessPawn = 62531,
	ChessPawnAlt = 62532,
	ChessQueen = 62533,
	ChessQueenAlt = 62534,
	ChessRook = 62535,
	ChessRookAlt = 62536,
	ChevronCircleDown = 61754,
	ChevronCircleLeft = 61751,
	ChevronCircleRight = 61752,
	ChevronCircleUp = 61753,
	ChevronDoubleDown = 62242,
	ChevronDoubleLeft = 62243,
	ChevronDoubleRight = 62244,
	ChevronDoubleUp = 62245,
	ChevronDown = 61560,
	ChevronLeft = 61523,
	ChevronRight = 61524,
	ChevronSquareDown = 62249,
	ChevronSquareLeft = 62250,
	ChevronSquareRight = 62251,
	ChevronSquareUp = 62252,
	ChevronUp = 61559,
	Child = 61870,
	Chimney = 63371,
	Church = 62749,
	Circle = 61713,
	CircleNotch = 61902,
	City = 63055,
	Clarinet = 63661,
	ClawMarks = 63170,
	ClinicMedical = 63474,
	Clipboard = 62248,
	ClipboardCheck = 62572,
	ClipboardList = 62573,
	ClipboardListCheck = 63287,
	ClipboardPrescription = 62952,
	ClipboardUser = 63475,
	Clock = 61463,
	Clone = 62029,
	ClosedCaptioning = 61962,
	Cloud = 61634,
	CloudDownload = 61677,
	CloudDownloadAlt = 62337,
	CloudDrizzle = 63288,
	CloudHail = 63289,
	CloudHailMixed = 63290,
	CloudMeatball = 63291,
	CloudMoon = 63171,
	CloudMoonRain = 63292,
	CloudMusic = 63662,
	CloudRain = 63293,
	CloudRainbow = 63294,
	CloudShowers = 63295,
	CloudShowersHeavy = 63296,
	CloudSleet = 63297,
	CloudSnow = 63298,
	CloudSun = 63172,
	CloudSunRain = 63299,
	CloudUpload = 61678,
	CloudUploadAlt = 62338,
	Clouds = 63300,
	CloudsMoon = 63301,
	CloudsSun = 63302,
	Club = 62247,
	Cocktail = 62817,
	Code = 61729,
	CodeBranch = 61734,
	CodeCommit = 62342,
	CodeMerge = 62343,
	Coffee = 61684,
	CoffeeTogo = 63173,
	Coffin = 63174,
	Cog = 61459,
	Cogs = 61573,
	Coin = 63580,
	Coins = 62750,
	Columns = 61659,
	Comment = 61557,
	CommentAlt = 62074,
	CommentAltCheck = 62626,
	CommentAltDollar = 63056,
	CommentAltDots = 62627,
	CommentAltEdit = 62628,
	CommentAltExclamation = 62629,
	CommentAltLines = 62630,
	CommentAltMedical = 63476,
	CommentAltMinus = 62631,
	CommentAltMusic = 63663,
	CommentAltPlus = 62632,
	CommentAltSlash = 62633,
	CommentAltSmile = 62634,
	CommentAltTimes = 62635,
	CommentCheck = 62636,
	CommentDollar = 63057,
	CommentDots = 62637,
	CommentEdit = 62638,
	CommentExclamation = 62639,
	CommentLines = 62640,
	CommentMedical = 63477,
	CommentMinus = 62641,
	CommentMusic = 63664,
	CommentPlus = 62642,
	CommentSlash = 62643,
	CommentSmile = 62644,
	CommentTimes = 62645,
	Comments = 61574,
	CommentsAlt = 62646,
	CommentsAltDollar = 63058,
	CommentsDollar = 63059,
	CompactDisc = 62751,
	Compass = 61774,
	CompassSlash = 62953,
	Compress = 61542,
	CompressAlt = 62498,
	CompressArrowsAlt = 63372,
	CompressWide = 62246,
	ComputerClassic = 63665,
	ComputerSpeaker = 63666,
	ConciergeBell = 62818,
	Construction = 63581,
	ContainerStorage = 62647,
	ConveyorBelt = 62574,
	ConveyorBeltAlt = 62575,
	Cookie = 62819,
	CookieBite = 62820,
	Copy = 61637,
	Copyright = 61945,
	Corn = 63175,
	Couch = 62648,
	Cow = 63176,
	Cowbell = 63667,
	CowbellMore = 63668,
	CreditCard = 61597,
	CreditCardBlank = 62345,
	CreditCardFront = 62346,
	Cricket = 62537,
	Croissant = 63478,
	Crop = 61733,
	CropAlt = 62821,
	Cross = 63060,
	Crosshairs = 61531,
	Crow = 62752,
	Crown = 62753,
	Crutch = 63479,
	Crutches = 63480,
	Cube = 61874,
	Cubes = 61875,
	Curling = 62538,
	Cut = 61636,
	Dagger = 63179,
	Database = 61888,
	Deaf = 62116,
	Debug = 63481,
	Deer = 63374,
	DeerRudolph = 63375,
	Democrat = 63303,
	Desktop = 61704,
	DesktopAlt = 62352,
	Dewpoint = 63304,
	Dharmachakra = 63061,
	Diagnoses = 62576,
	Diamond = 61977,
	Dice = 62754,
	DiceD10 = 63181,
	DiceD12 = 63182,
	DiceD20 = 63183,
	DiceD4 = 63184,
	DiceD6 = 63185,
	DiceD8 = 63186,
	DiceFive = 62755,
	DiceFour = 62756,
	DiceOne = 62757,
	DiceSix = 62758,
	DiceThree = 62759,
	DiceTwo = 62760,
	Digging = 63582,
	DigitalTachograph = 62822,
	Diploma = 62954,
	Directions = 62955,
	DiscDrive = 63669,
	Disease = 63482,
	Divide = 62761,
	Dizzy = 62823,
	Dna = 62577,
	DoNotEnter = 62956,
	Dog = 63187,
	DogLeashed = 63188,
	DollarSign = 61781,
	Dolly = 62578,
	DollyEmpty = 62579,
	DollyFlatbed = 62580,
	DollyFlatbedAlt = 62581,
	DollyFlatbedEmpty = 62582,
	Donate = 62649,
	DoorClosed = 62762,
	DoorOpen = 62763,
	DotCircle = 61842,
	Dove = 62650,
	Download = 61465,
	DraftingCompass = 62824,
	Dragon = 63189,
	DrawCircle = 62957,
	DrawPolygon = 62958,
	DrawSquare = 62959,
	Dreidel = 63378,
	Drone = 63583,
	DroneAlt = 63584,
	Drum = 62825,
	DrumSteelpan = 62826,
	Drumstick = 63190,
	DrumstickBite = 63191,
	Dryer = 63585,
	DryerAlt = 63586,
	Duck = 63192,
	Dumbbell = 62539,
	Dumpster = 63379,
	DumpsterFire = 63380,
	Dungeon = 63193,
	Ear = 62960,
	EarMuffs = 63381,
	Eclipse = 63305,
	EclipseAlt = 63306,
	Edit = 61508,
	Egg = 63483,
	EggFried = 63484,
	Eject = 61522,
	Elephant = 63194,
	EllipsisH = 61761,
	EllipsisHAlt = 62363,
	EllipsisV = 61762,
	EllipsisVAlt = 62364,
	EmptySet = 63062,
	EngineWarning = 62962,
	Envelope = 61664,
	EnvelopeOpen = 62134,
	EnvelopeOpenDollar = 63063,
	EnvelopeOpenText = 63064,
	EnvelopeSquare = 61849,
	Equals = 62764,
	Eraser = 61741,
	Ethernet = 63382,
	EuroSign = 61779,
	Exchange = 61676,
	ExchangeAlt = 62306,
	Exclamation = 61738,
	ExclamationCircle = 61546,
	ExclamationSquare = 62241,
	ExclamationTriangle = 61553,
	Expand = 61541,
	ExpandAlt = 62500,
	ExpandArrows = 62237,
	ExpandArrowsAlt = 62238,
	ExpandWide = 62240,
	ExternalLink = 61582,
	ExternalLinkAlt = 62301,
	ExternalLinkSquare = 61772,
	ExternalLinkSquareAlt = 62304,
	Eye = 61550,
	EyeDropper = 61947,
	EyeEvil = 63195,
	EyeSlash = 61552,
	Fan = 63587,
	Farm = 63588,
	FastBackward = 61513,
	FastForward = 61520,
	Fax = 61868,
	Feather = 62765,
	FeatherAlt = 62827,
	Female = 61826,
	FieldHockey = 62540,
	FighterJet = 61691,
	File = 61787,
	FileAlt = 61788,
	FileArchive = 61894,
	FileAudio = 61895,
	FileCertificate = 62963,
	FileChartLine = 63065,
	FileChartPie = 63066,
	FileCheck = 62230,
	FileCode = 61897,
	FileContract = 62828,
	FileCsv = 63197,
	FileDownload = 62829,
	FileEdit = 62236,
	FileExcel = 61891,
	FileExclamation = 62234,
	FileExport = 62830,
	FileImage = 61893,
	FileImport = 62831,
	FileInvoice = 62832,
	FileInvoiceDollar = 62833,
	FileMedical = 62583,
	FileMedicalAlt = 62584,
	FileMinus = 62232,
	FileMusic = 63670,
	FilePdf = 61889,
	FilePlus = 62233,
	FilePowerpoint = 61892,
	FilePrescription = 62834,
	FileSearch = 63589,
	FileSignature = 62835,
	FileSpreadsheet = 63067,
	FileTimes = 62231,
	FileUpload = 62836,
	FileUser = 63068,
	FileVideo = 61896,
	FileWord = 61890,
	FilesMedical = 63485,
	Fill = 62837,
	FillDrip = 62838,
	Film = 61448,
	FilmAlt = 62368,
	FilmCanister = 63671,
	Filter = 61616,
	Fingerprint = 62839,
	Fire = 61549,
	FireAlt = 63460,
	FireExtinguisher = 61748,
	FireSmoke = 63307,
	Fireplace = 63386,
	FirstAid = 62585,
	Fish = 62840,
	FishCooked = 63486,
	FistRaised = 63198,
	Flag = 61476,
	FlagAlt = 63308,
	FlagCheckered = 61726,
	FlagUsa = 63309,
	Flame = 63199,
	Flashlight = 63672,
	Flask = 61635,
	FlaskPoison = 63200,
	FlaskPotion = 63201,
	Flower = 63487,
	FlowerDaffodil = 63488,
	FlowerTulip = 63489,
	Flushed = 62841,
	Flute = 63673,
	FluxCapacitor = 63674,
	Fog = 63310,
	Folder = 61563,
	FolderMinus = 63069,
	FolderOpen = 61564,
	FolderPlus = 63070,
	FolderTimes = 63071,
	FolderTree = 63490,
	Folders = 63072,
	Font = 61489,
	FontAwesomeLogoFull = 62694,
	FontCase = 63590,
	FootballBall = 62542,
	FootballHelmet = 62543,
	Forklift = 62586,
	Forward = 61518,
	Fragile = 62651,
	FrenchFries = 63491,
	Frog = 62766,
	FrostyHead = 63387,
	Frown = 61721,
	FrownOpen = 62842,
	Function = 63073,
	FunnelDollar = 63074,
	Futbol = 61923,
	GameBoard = 63591,
	GameBoardAlt = 63592,
	GameConsoleHandheld = 63675,
	Gamepad = 61723,
	GamepadAlt = 63676,
	GasPump = 62767,
	GasPumpSlash = 62964,
	Gavel = 61667,
	Gem = 62373,
	Genderless = 61997,
	Ghost = 63202,
	Gift = 61547,
	GiftCard = 63075,
	Gifts = 63388,
	GingerbreadMan = 63389,
	Glass = 63492,
	GlassChampagne = 63390,
	GlassCheers = 63391,
	GlassCitrus = 63593,
	GlassMartini = 61440,
	GlassMartiniAlt = 62843,
	GlassWhiskey = 63392,
	GlassWhiskeyRocks = 63393,
	Glasses = 62768,
	GlassesAlt = 62965,
	Globe = 61612,
	GlobeAfrica = 62844,
	GlobeAmericas = 62845,
	GlobeAsia = 62846,
	GlobeEurope = 63394,
	GlobeSnow = 63395,
	GlobeStand = 62966,
	GolfBall = 62544,
	GolfClub = 62545,
	Gopuram = 63076,
	GraduationCap = 61853,
	Gramophone = 63677,
	GreaterThan = 62769,
	GreaterThanEqual = 62770,
	Grimace = 62847,
	Grin = 62848,
	GrinAlt = 62849,
	GrinBeam = 62850,
	GrinBeamSweat = 62851,
	GrinHearts = 62852,
	GrinSquint = 62853,
	GrinSquintTears = 62854,
	GrinStars = 62855,
	GrinTears = 62856,
	GrinTongue = 62857,
	GrinTongueSquint = 62858,
	GrinTongueWink = 62859,
	GrinWink = 62860,
	GripHorizontal = 62861,
	GripLines = 63396,
	GripLinesVertical = 63397,
	GripVertical = 62862,
	Guitar = 63398,
	GuitarElectric = 63678,
	Guitars = 63679,
	HSquare = 61693,
	H1 = 62227,
	H2 = 62228,
	H3 = 62229,
	H4 = 63594,
	Hamburger = 63493,
	Hammer = 63203,
	HammerWar = 63204,
	Hamsa = 63077,
	HandHeart = 62652,
	HandHolding = 62653,
	HandHoldingBox = 62587,
	HandHoldingHeart = 62654,
	HandHoldingMagic = 63205,
	HandHoldingSeedling = 62655,
	HandHoldingUsd = 62656,
	HandHoldingWater = 62657,
	HandLizard = 62040,
	HandMiddleFinger = 63494,
	HandPaper = 62038,
	HandPeace = 62043,
	HandPointDown = 61607,
	HandPointLeft = 61605,
	HandPointRight = 61604,
	HandPointUp = 61606,
	HandPointer = 62042,
	HandReceiving = 62588,
	HandRock = 62037,
	HandScissors = 62039,
	HandSpock = 62041,
	Hands = 62658,
	HandsHeart = 62659,
	HandsHelping = 62660,
	HandsUsd = 62661,
	Handshake = 62133,
	HandshakeAlt = 62662,
	Hanukiah = 63206,
	HardHat = 63495,
	Hashtag = 62098,
	HatChef = 63595,
	HatCowboy = 63680,
	HatCowboySide = 63681,
	HatSanta = 63399,
	HatWinter = 63400,
	HatWitch = 63207,
	HatWizard = 63208,
	Haykal = 63078,
	Hdd = 61600,
	HeadSide = 63209,
	HeadSideBrain = 63496,
	HeadSideHeadphones = 63682,
	HeadSideMedical = 63497,
	HeadVr = 63210,
	Heading = 61916,
	Headphones = 61477,
	HeadphonesAlt = 62863,
	Headset = 62864,
	Heart = 61444,
	HeartBroken = 63401,
	HeartCircle = 62663,
	HeartRate = 62968,
	HeartSquare = 62664,
	Heartbeat = 61982,
	Helicopter = 62771,
	HelmetBattle = 63211,
	Hexagon = 62226,
	Highlighter = 62865,
	Hiking = 63212,
	Hippo = 63213,
	History = 61914,
	HockeyMask = 63214,
	HockeyPuck = 62547,
	HockeySticks = 62548,
	HollyBerry = 63402,
	Home = 61461,
	HomeAlt = 63498,
	HomeHeart = 62665,
	HomeLg = 63499,
	HomeLgAlt = 63500,
	HoodCloak = 63215,
	HorizontalRule = 63596,
	Horse = 63216,
	HorseHead = 63403,
	HorseSaddle = 63683,
	Hospital = 61688,
	HospitalAlt = 62589,
	HospitalSymbol = 62590,
	HospitalUser = 63501,
	Hospitals = 63502,
	HotTub = 62867,
	Hotdog = 63503,
	Hotel = 62868,
	Hourglass = 62036,
	HourglassEnd = 62035,
	HourglassHalf = 62034,
	HourglassStart = 62033,
	HouseDamage = 63217,
	HouseFlood = 63311,
	Hryvnia = 63218,
	Humidity = 63312,
	Hurricane = 63313,
	ICursor = 62022,
	IceCream = 63504,
	IceSkate = 63404,
	Icicles = 63405,
	Icons = 63597,
	IconsAlt = 63598,
	IdBadge = 62145,
	IdCard = 62146,
	IdCardAlt = 62591,
	Igloo = 63406,
	Image = 61502,
	ImagePolaroid = 63684,
	Images = 62210,
	Inbox = 61468,
	InboxIn = 62224,
	InboxOut = 62225,
	Indent = 61500,
	Industry = 62069,
	IndustryAlt = 62387,
	Infinity = 62772,
	Info = 61737,
	InfoCircle = 61530,
	InfoSquare = 62223,
	Inhaler = 62969,
	Integral = 63079,
	Intersection = 63080,
	Inventory = 62592,
	IslandTropical = 63505,
	Italic = 61491,
	JackOLantern = 62222,
	Jedi = 63081,
	Joint = 62869,
	JournalWhills = 63082,
	Joystick = 63685,
	Jug = 63686,
	Kaaba = 63083,
	Kazoo = 63687,
	Kerning = 63599,
	Key = 61572,
	KeySkeleton = 63219,
	Keyboard = 61724,
	Keynote = 63084,
	Khanda = 63085,
	Kidneys = 62971,
	Kiss = 62870,
	KissBeam = 62871,
	KissWinkHeart = 62872,
	Kite = 63220,
	KiwiBird = 62773,
	KnifeKitchen = 63221,
	Lambda = 63086,
	Lamp = 62666,
	Landmark = 63087,
	LandmarkAlt = 63314,
	Language = 61867,
	Laptop = 61705,
	LaptopCode = 62972,
	LaptopMedical = 63506,
	Lasso = 63688,
	Laugh = 62873,
	LaughBeam = 62874,
	LaughSquint = 62875,
	LaughWink = 62876,
	LayerGroup = 62973,
	LayerMinus = 62974,
	LayerPlus = 62975,
	Leaf = 61548,
	LeafHeart = 62667,
	LeafMaple = 63222,
	LeafOak = 63223,
	Lemon = 61588,
	LessThan = 62774,
	LessThanEqual = 62775,
	LevelDown = 61769,
	LevelDownAlt = 62398,
	LevelUp = 61768,
	LevelUpAlt = 62399,
	LifeRing = 61901,
	Lightbulb = 61675,
	LightbulbDollar = 63088,
	LightbulbExclamation = 63089,
	LightbulbOn = 63090,
	LightbulbSlash = 63091,
	LightsHoliday = 63410,
	LineColumns = 63600,
	LineHeight = 63601,
	Link = 61633,
	Lips = 62976,
	LiraSign = 61845,
	List = 61498,
	ListAlt = 61474,
	ListMusic = 63689,
	ListOl = 61643,
	ListUl = 61642,
	Location = 62977,
	LocationArrow = 61732,
	LocationCircle = 62978,
	LocationSlash = 62979,
	Lock = 61475,
	LockAlt = 62221,
	LockOpen = 62401,
	LockOpenAlt = 62402,
	LongArrowAltDown = 62217,
	LongArrowAltLeft = 62218,
	LongArrowAltRight = 62219,
	LongArrowAltUp = 62220,
	LongArrowDown = 61813,
	LongArrowLeft = 61815,
	LongArrowRight = 61816,
	LongArrowUp = 61814,
	Loveseat = 62668,
	LowVision = 62120,
	Luchador = 62549,
	LuggageCart = 62877,
	Lungs = 62980,
	Mace = 63224,
	Magic = 61648,
	Magnet = 61558,
	MailBulk = 63092,
	Mailbox = 63507,
	Male = 61827,
	Mandolin = 63225,
	Map = 62073,
	MapMarked = 62879,
	MapMarkedAlt = 62880,
	MapMarker = 61505,
	MapMarkerAlt = 62405,
	MapMarkerAltSlash = 62981,
	MapMarkerCheck = 62982,
	MapMarkerEdit = 62983,
	MapMarkerExclamation = 62984,
	MapMarkerMinus = 62985,
	MapMarkerPlus = 62986,
	MapMarkerQuestion = 62987,
	MapMarkerSlash = 62988,
	MapMarkerSmile = 62989,
	MapMarkerTimes = 62990,
	MapPin = 62070,
	MapSigns = 62071,
	Marker = 62881,
	Mars = 61986,
	MarsDouble = 61991,
	MarsStroke = 61993,
	MarsStrokeH = 61995,
	MarsStrokeV = 61994,
	Mask = 63226,
	Meat = 63508,
	Medal = 62882,
	Medkit = 61690,
	Megaphone = 63093,
	Meh = 61722,
	MehBlank = 62884,
	MehRollingEyes = 62885,
	Memory = 62776,
	Menorah = 63094,
	Mercury = 61987,
	Meteor = 63315,
	Microchip = 62171,
	Microphone = 61744,
	MicrophoneAlt = 62409,
	MicrophoneAltSlash = 62777,
	MicrophoneSlash = 61745,
	MicrophoneStand = 63691,
	Microscope = 62992,
	MindShare = 63095,
	Minus = 61544,
	MinusCircle = 61526,
	MinusHexagon = 62215,
	MinusOctagon = 62216,
	MinusSquare = 61766,
	Mistletoe = 63412,
	Mitten = 63413,
	Mobile = 61707,
	MobileAlt = 62413,
	MobileAndroid = 62414,
	MobileAndroidAlt = 62415,
	MoneyBill = 61654,
	MoneyBillAlt = 62417,
	MoneyBillWave = 62778,
	MoneyBillWaveAlt = 62779,
	MoneyCheck = 62780,
	MoneyCheckAlt = 62781,
	MoneyCheckEdit = 63602,
	MoneyCheckEditAlt = 63603,
	MonitorHeartRate = 62993,
	Monkey = 63227,
	Monument = 62886,
	Moon = 61830,
	MoonCloud = 63316,
	MoonStars = 63317,
	MortarPestle = 62887,
	Mosque = 63096,
	Motorcycle = 61980,
	Mountain = 63228,
	Mountains = 63229,
	Mouse = 63692,
	MouseAlt = 63693,
	MousePointer = 62021,
	Mp3Player = 63694,
	Mug = 63604,
	MugHot = 63414,
	MugMarshmallows = 63415,
	MugTea = 63605,
	Music = 61441,
	MusicAlt = 63695,
	MusicAltSlash = 63696,
	MusicSlash = 63697,
	Narwhal = 63230,
	NetworkWired = 63231,
	Neuter = 61996,
	Newspaper = 61930,
	NotEqual = 62782,
	NotesMedical = 62593,
	ObjectGroup = 62023,
	ObjectUngroup = 62024,
	Octagon = 62214,
	OilCan = 62995,
	OilTemp = 62996,
	Om = 63097,
	Omega = 63098,
	Ornament = 63416,
	Otter = 63232,
	Outdent = 61499,
	Overline = 63606,
	PageBreak = 63607,
	Pager = 63509,
	PaintBrush = 61948,
	PaintBrushAlt = 62889,
	PaintRoller = 62890,
	Palette = 62783,
	Pallet = 62594,
	PalletAlt = 62595,
	PaperPlane = 61912,
	Paperclip = 61638,
	ParachuteBox = 62669,
	Paragraph = 61917,
	ParagraphRtl = 63608,
	Parking = 62784,
	ParkingCircle = 62997,
	ParkingCircleSlash = 62998,
	ParkingSlash = 62999,
	Passport = 62891,
	Pastafarianism = 63099,
	Paste = 61674,
	Pause = 61516,
	PauseCircle = 62091,
	Paw = 61872,
	PawAlt = 63233,
	PawClaws = 63234,
	Peace = 63100,
	Pegasus = 63235,
	Pen = 62212,
	PenAlt = 62213,
	PenFancy = 62892,
	PenNib = 62893,
	PenSquare = 61771,
	Pencil = 61504,
	PencilAlt = 62211,
	PencilPaintbrush = 63000,
	PencilRuler = 62894,
	Pennant = 62550,
	PeopleCarry = 62670,
	PepperHot = 63510,
	Percent = 62101,
	Percentage = 62785,
	PersonBooth = 63318,
	PersonCarry = 62671,
	PersonDolly = 62672,
	PersonDollyEmpty = 62673,
	PersonSign = 63319,
	Phone = 61589,
	PhoneAlt = 63609,
	PhoneLaptop = 63610,
	PhoneOffice = 63101,
	PhonePlus = 62674,
	PhoneRotary = 63699,
	PhoneSlash = 62429,
	PhoneSquare = 61592,
	PhoneSquareAlt = 63611,
	PhoneVolume = 62112,
	PhotoVideo = 63612,
	Pi = 63102,
	Piano = 63700,
	PianoKeyboard = 63701,
	Pie = 63237,
	Pig = 63238,
	PiggyBank = 62675,
	Pills = 62596,
	Pizza = 63511,
	PizzaSlice = 63512,
	PlaceOfWorship = 63103,
	Plane = 61554,
	PlaneAlt = 62430,
	PlaneArrival = 62895,
	PlaneDeparture = 62896,
	Play = 61515,
	PlayCircle = 61764,
	Plug = 61926,
	Plus = 61543,
	PlusCircle = 61525,
	PlusHexagon = 62208,
	PlusOctagon = 62209,
	PlusSquare = 61694,
	Podcast = 62158,
	Podium = 63104,
	PodiumStar = 63320,
	Poll = 63105,
	PollH = 63106,
	PollPeople = 63321,
	Poo = 62206,
	PooStorm = 63322,
	Poop = 63001,
	Popcorn = 63513,
	Portrait = 62432,
	PoundSign = 61780,
	PowerOff = 61457,
	Pray = 63107,
	PrayingHands = 63108,
	Prescription = 62897,
	PrescriptionBottle = 62597,
	PrescriptionBottleAlt = 62598,
	Presentation = 63109,
	Print = 61487,
	PrintSearch = 63514,
	PrintSlash = 63110,
	Procedures = 62599,
	ProjectDiagram = 62786,
	Projector = 63702,
	Pumpkin = 63239,
	PuzzlePiece = 61742,
	Qrcode = 61481,
	Question = 61736,
	QuestionCircle = 61529,
	QuestionSquare = 62205,
	Quidditch = 62552,
	QuoteLeft = 61709,
	QuoteRight = 61710,
	Quran = 63111,
	Rabbit = 63240,
	RabbitFast = 63241,
	Racquet = 62554,
	Radiation = 63417,
	RadiationAlt = 63418,
	Radio = 63703,
	RadioAlt = 63704,
	Rainbow = 63323,
	Raindrops = 63324,
	Ram = 63242,
	RampLoading = 62676,
	Random = 61556,
	Receipt = 62787,
	RecordVinyl = 63705,
	RectangleLandscape = 62202,
	RectanglePortrait = 62203,
	RectangleWide = 62204,
	Recycle = 61880,
	Redo = 61470,
	RedoAlt = 62201,
	Registered = 62045,
	RemoveFormat = 63613,
	Repeat = 62307,
	Repeat1 = 62309,
	Repeat1Alt = 62310,
	RepeatAlt = 62308,
	Reply = 62437,
	ReplyAll = 61730,
	Republican = 63326,
	Restroom = 63421,
	Retweet = 61561,
	RetweetAlt = 62305,
	Ribbon = 62678,
	Ring = 63243,
	RingsWedding = 63515,
	Road = 61464,
	Robot = 62788,
	Rocket = 61749,
	Route = 62679,
	RouteHighway = 63002,
	RouteInterstate = 63003,
	Router = 63706,
	Rss = 61598,
	RssSquare = 61763,
	RubleSign = 61784,
	Ruler = 62789,
	RulerCombined = 62790,
	RulerHorizontal = 62791,
	RulerTriangle = 63004,
	RulerVertical = 62792,
	Running = 63244,
	RupeeSign = 61782,
	Rv = 63422,
	Sack = 63516,
	SackDollar = 63517,
	SadCry = 62899,
	SadTear = 62900,
	Salad = 63518,
	Sandwich = 63519,
	Satellite = 63423,
	SatelliteDish = 63424,
	Sausage = 63520,
	Save = 61639,
	SaxHot = 63707,
	Saxophone = 63708,
	Scalpel = 63005,
	ScalpelPath = 63006,
	Scanner = 62600,
	ScannerImage = 63731,
	ScannerKeyboard = 62601,
	ScannerTouchscreen = 62602,
	Scarecrow = 63245,
	Scarf = 63425,
	School = 62793,
	Screwdriver = 62794,
	Scroll = 63246,
	ScrollOld = 63247,
	Scrubber = 62200,
	Scythe = 63248,
	SdCard = 63426,
	Search = 61442,
	SearchDollar = 63112,
	SearchLocation = 63113,
	SearchMinus = 61456,
	SearchPlus = 61454,
	Seedling = 62680,
	SendBack = 63614,
	SendBackward = 63615,
	Server = 62003,
	Shapes = 63007,
	Share = 61540,
	ShareAll = 62311,
	ShareAlt = 61920,
	ShareAltSquare = 61921,
	ShareSquare = 61773,
	Sheep = 63249,
	ShekelSign = 61963,
	Shield = 61746,
	ShieldAlt = 62445,
	ShieldCheck = 62199,
	ShieldCross = 63250,
	Ship = 61978,
	ShippingFast = 62603,
	ShippingTimed = 62604,
	ShishKebab = 63521,
	ShoePrints = 62795,
	ShoppingBag = 62096,
	ShoppingBasket = 62097,
	ShoppingCart = 61562,
	Shovel = 63251,
	ShovelSnow = 63427,
	Shower = 62156,
	Shredder = 63114,
	ShuttleVan = 62902,
	Shuttlecock = 62555,
	Sickle = 63522,
	Sigma = 63115,
	Sign = 62681,
	SignIn = 61584,
	SignInAlt = 62198,
	SignLanguage = 62119,
	SignOut = 61579,
	SignOutAlt = 62197,
	Signal = 61458,
	Signal1 = 63116,
	Signal2 = 63117,
	Signal3 = 63118,
	Signal4 = 63119,
	SignalAlt = 63120,
	SignalAlt1 = 63121,
	SignalAlt2 = 63122,
	SignalAlt3 = 63123,
	SignalAltSlash = 63124,
	SignalSlash = 63125,
	SignalStream = 63709,
	Signature = 62903,
	SimCard = 63428,
	Sitemap = 61672,
	Skating = 63429,
	Skeleton = 63008,
	SkiJump = 63431,
	SkiLift = 63432,
	Skiing = 63433,
	SkiingNordic = 63434,
	Skull = 62796,
	SkullCow = 63710,
	SkullCrossbones = 63252,
	Slash = 63253,
	Sledding = 63435,
	Sleigh = 63436,
	SlidersH = 61918,
	SlidersHSquare = 62448,
	SlidersV = 62449,
	SlidersVSquare = 62450,
	Smile = 61720,
	SmileBeam = 62904,
	SmilePlus = 62905,
	SmileWink = 62682,
	Smog = 63327,
	Smoke = 63328,
	Smoking = 62605,
	SmokingBan = 62797,
	Sms = 63437,
	Snake = 63254,
	Snooze = 63616,
	SnowBlowing = 63329,
	Snowboarding = 63438,
	Snowflake = 62172,
	Snowflakes = 63439,
	Snowman = 63440,
	Snowmobile = 63441,
	Snowplow = 63442,
	Socks = 63126,
	SolarPanel = 62906,
	Sort = 61660,
	SortAlphaDown = 61789,
	SortAlphaDownAlt = 63617,
	SortAlphaUp = 61790,
	SortAlphaUpAlt = 63618,
	SortAlt = 63619,
	SortAmountDown = 61792,
	SortAmountDownAlt = 63620,
	SortAmountUp = 61793,
	SortAmountUpAlt = 63621,
	SortDown = 61661,
	SortNumericDown = 61794,
	SortNumericDownAlt = 63622,
	SortNumericUp = 61795,
	SortNumericUpAlt = 63623,
	SortShapesDown = 63624,
	SortShapesDownAlt = 63625,
	SortShapesUp = 63626,
	SortShapesUpAlt = 63627,
	SortSizeDown = 63628,
	SortSizeDownAlt = 63629,
	SortSizeUp = 63630,
	SortSizeUpAlt = 63631,
	SortUp = 61662,
	Soup = 63523,
	Spa = 62907,
	SpaceShuttle = 61847,
	Spade = 62196,
	Sparkles = 63632,
	Speaker = 63711,
	Speakers = 63712,
	SpellCheck = 63633,
	Spider = 63255,
	SpiderBlackWidow = 63256,
	SpiderWeb = 63257,
	Spinner = 61712,
	SpinnerThird = 62452,
	Splotch = 62908,
	SprayCan = 62909,
	Square = 61640,
	SquareFull = 62556,
	SquareRoot = 63127,
	SquareRootAlt = 63128,
	Squirrel = 63258,
	Staff = 63259,
	Stamp = 62911,
	Star = 61445,
	StarAndCrescent = 63129,
	StarChristmas = 63444,
	StarExclamation = 62195,
	StarHalf = 61577,
	StarHalfAlt = 62912,
	StarOfDavid = 63130,
	StarOfLife = 63009,
	Stars = 63330,
	Steak = 63524,
	SteeringWheel = 63010,
	StepBackward = 61512,
	StepForward = 61521,
	Stethoscope = 61681,
	StickyNote = 62025,
	Stocking = 63445,
	Stomach = 63011,
	Stop = 61517,
	StopCircle = 62093,
	Stopwatch = 62194,
	Store = 62798,
	StoreAlt = 62799,
	Stream = 62800,
	StreetView = 61981,
	Stretcher = 63525,
	Strikethrough = 61644,
	Stroopwafel = 62801,
	Subscript = 61740,
	Subway = 62009,
	Suitcase = 61682,
	SuitcaseRolling = 62913,
	Sun = 61829,
	SunCloud = 63331,
	SunDust = 63332,
	SunHaze = 63333,
	Sunglasses = 63634,
	Sunrise = 63334,
	Sunset = 63335,
	Superscript = 61739,
	Surprise = 62914,
	Swatchbook = 62915,
	Swimmer = 62916,
	SwimmingPool = 62917,
	Sword = 63260,
	Swords = 63261,
	Synagogue = 63131,
	Sync = 61473,
	SyncAlt = 62193,
	Syringe = 62606,
	Table = 61646,
	TableTennis = 62557,
	Tablet = 61706,
	TabletAlt = 62458,
	TabletAndroid = 62459,
	TabletAndroidAlt = 62460,
	TabletRugged = 62607,
	Tablets = 62608,
	Tachometer = 61668,
	TachometerAlt = 62461,
	TachometerAltAverage = 63012,
	TachometerAltFast = 63013,
	TachometerAltFastest = 63014,
	TachometerAltSlow = 63015,
	TachometerAltSlowest = 63016,
	TachometerAverage = 63017,
	TachometerFast = 63018,
	TachometerFastest = 63019,
	TachometerSlow = 63020,
	TachometerSlowest = 63021,
	Taco = 63526,
	Tag = 61483,
	Tags = 61484,
	Tally = 63132,
	Tanakh = 63527,
	Tape = 62683,
	Tasks = 61614,
	TasksAlt = 63528,
	Taxi = 61882,
	Teeth = 63022,
	TeethOpen = 63023,
	TemperatureFrigid = 63336,
	TemperatureHigh = 63337,
	TemperatureHot = 63338,
	TemperatureLow = 63339,
	Tenge = 63447,
	TennisBall = 62558,
	Terminal = 61728,
	Text = 63635,
	TextHeight = 61492,
	TextSize = 63636,
	TextWidth = 61493,
	Th = 61450,
	ThLarge = 61449,
	ThList = 61451,
	TheaterMasks = 63024,
	Thermometer = 62609,
	ThermometerEmpty = 62155,
	ThermometerFull = 62151,
	ThermometerHalf = 62153,
	ThermometerQuarter = 62154,
	ThermometerThreeQuarters = 62152,
	Theta = 63134,
	ThumbsDown = 61797,
	ThumbsUp = 61796,
	Thumbtack = 61581,
	Thunderstorm = 63340,
	ThunderstormMoon = 63341,
	ThunderstormSun = 63342,
	Ticket = 61765,
	TicketAlt = 62463,
	Tilde = 63135,
	Times = 61453,
	TimesCircle = 61527,
	TimesHexagon = 62190,
	TimesOctagon = 62192,
	TimesSquare = 62163,
	Tint = 61507,
	TintSlash = 62919,
	Tire = 63025,
	TireFlat = 63026,
	TirePressureWarning = 63027,
	TireRugged = 63028,
	Tired = 62920,
	ToggleOff = 61956,
	ToggleOn = 61957,
	Toilet = 63448,
	ToiletPaper = 63262,
	ToiletPaperAlt = 63263,
	Tombstone = 63264,
	TombstoneAlt = 63265,
	Toolbox = 62802,
	Tools = 63449,
	Tooth = 62921,
	Toothbrush = 63029,
	Torah = 63136,
	ToriiGate = 63137,
	Tornado = 63343,
	Tractor = 63266,
	Trademark = 62044,
	TrafficCone = 63030,
	TrafficLight = 63031,
	TrafficLightGo = 63032,
	TrafficLightSlow = 63033,
	TrafficLightStop = 63034,
	Train = 62008,
	Tram = 63450,
	Transgender = 61988,
	TransgenderAlt = 61989,
	Trash = 61944,
	TrashAlt = 62189,
	TrashRestore = 63529,
	TrashRestoreAlt = 63530,
	TrashUndo = 63637,
	TrashUndoAlt = 63638,
	TreasureChest = 63267,
	Tree = 61883,
	TreeAlt = 62464,
	TreeChristmas = 63451,
	TreeDecorated = 63452,
	TreeLarge = 63453,
	TreePalm = 63531,
	Trees = 63268,
	Triangle = 62188,
	TriangleMusic = 63714,
	Trophy = 61585,
	TrophyAlt = 62187,
	Truck = 61649,
	TruckContainer = 62684,
	TruckCouch = 62685,
	TruckLoading = 62686,
	TruckMonster = 63035,
	TruckMoving = 62687,
	TruckPickup = 63036,
	TruckPlow = 63454,
	TruckRamp = 62688,
	Trumpet = 63715,
	Tshirt = 62803,
	Tty = 61924,
	Turkey = 63269,
	Turntable = 63716,
	Turtle = 63270,
	Tv = 62060,
	TvAlt = 63717,
	TvMusic = 63718,
	TvRetro = 62465,
	Typewriter = 63719,
	Umbrella = 61673,
	UmbrellaBeach = 62922,
	Underline = 61645,
	Undo = 61666,
	UndoAlt = 62186,
	Unicorn = 63271,
	Union = 63138,
	UniversalAccess = 62106,
	University = 61852,
	Unlink = 61735,
	Unlock = 61596,
	UnlockAlt = 61758,
	Upload = 61587,
	UsbDrive = 63721,
	UsdCircle = 62184,
	UsdSquare = 62185,
	User = 61447,
	UserAlt = 62470,
	UserAltSlash = 62714,
	UserAstronaut = 62715,
	UserChart = 63139,
	UserCheck = 62716,
	UserCircle = 62141,
	UserClock = 62717,
	UserCog = 62718,
	UserCowboy = 63722,
	UserCrown = 63140,
	UserEdit = 62719,
	UserFriends = 62720,
	UserGraduate = 62721,
	UserHardHat = 63532,
	UserHeadset = 63533,
	UserInjured = 63272,
	UserLock = 62722,
	UserMd = 61680,
	UserMdChat = 63534,
	UserMinus = 62723,
	UserMusic = 63723,
	UserNinja = 62724,
	UserNurse = 63535,
	UserPlus = 62004,
	UserSecret = 61979,
	UserShield = 62725,
	UserSlash = 62726,
	UserTag = 62727,
	UserTie = 62728,
	UserTimes = 62005,
	Users = 61632,
	UsersClass = 63037,
	UsersCog = 62729,
	UsersCrown = 63141,
	UsersMedical = 63536,
	UtensilFork = 62179,
	UtensilKnife = 62180,
	UtensilSpoon = 62181,
	Utensils = 62183,
	UtensilsAlt = 62182,
	ValueAbsolute = 63142,
	VectorSquare = 62923,
	Venus = 61985,
	VenusDouble = 61990,
	VenusMars = 61992,
	Vhs = 63724,
	Vial = 62610,
	Vials = 62611,
	Video = 61501,
	VideoPlus = 62689,
	VideoSlash = 62690,
	Vihara = 63143,
	Violin = 63725,
	Voicemail = 63639,
	Volcano = 63344,
	VolleyballBall = 62559,
	Volume = 63144,
	VolumeDown = 61479,
	VolumeMute = 63145,
	VolumeOff = 61478,
	VolumeSlash = 62178,
	VolumeUp = 61480,
	VoteNay = 63345,
	VoteYea = 63346,
	VrCardboard = 63273,
	WagonCovered = 63726,
	Walker = 63537,
	WalkieTalkie = 63727,
	Walking = 62804,
	Wallet = 62805,
	Wand = 63274,
	WandMagic = 63275,
	Warehouse = 62612,
	WarehouseAlt = 62613,
	Washer = 63640,
	Watch = 62177,
	WatchCalculator = 63728,
	WatchFitness = 63038,
	Water = 63347,
	WaterLower = 63348,
	WaterRise = 63349,
	WaveSine = 63641,
	WaveSquare = 63550,
	WaveTriangle = 63642,
	Waveform = 63729,
	WaveformPath = 63730,
	Webcam = 63538,
	WebcamSlash = 63539,
	Weight = 62614,
	WeightHanging = 62925,
	Whale = 63276,
	Wheat = 63277,
	Wheelchair = 61843,
	Whistle = 62560,
	Wifi = 61931,
	Wifi1 = 63146,
	Wifi2 = 63147,
	WifiSlash = 63148,
	Wind = 63278,
	WindTurbine = 63643,
	WindWarning = 63350,
	Window = 62478,
	WindowAlt = 62479,
	WindowClose = 62480,
	WindowMaximize = 62160,
	WindowMinimize = 62161,
	WindowRestore = 62162,
	Windsock = 63351,
	WineBottle = 63279,
	WineGlass = 62691,
	WineGlassAlt = 62926,
	WonSign = 61785,
	Wreath = 63458,
	Wrench = 61613,
	XRay = 62615,
	YenSign = 61783,
	YinYang = 63149
}


using UnityEngine;
using UnityEngine.UI;

public class LoadingBar : MonoBehaviour
{
	public CanvasGroup Canvas;

	public Text Label;

	public Text SubLabel;

	public Image ProgressImage;

	public bool Active
	{
		set
		{
			if (Object.op_Implicit((Object)(object)Canvas))
			{
				Canvas.alpha = (value ? 1f : 0f);
			}
		}
	}

	public float Progress
	{
		set
		{
			if (Object.op_Implicit((Object)(object)ProgressImage))
			{
				ProgressImage.fillAmount = value;
			}
		}
	}

	public string Text
	{
		set
		{
			if (Object.op_Implicit((Object)(object)Label))
			{
				Label.text = value;
			}
		}
	}

	public string SubText
	{
		set
		{
			if (Object.op_Implicit((Object)(object)SubLabel))
			{
				SubLabel.text = value;
			}
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public static class Make
{
	public static class Container
	{
		public static RustWrapper Toolbar(string style = "Normal")
		{
			return Manager.Create<RustWrapper>(PrefabRoot + "Container.Toolbar." + style + ".prefab");
		}

		public static RustWrapper Popup(string style = "Normal")
		{
			return Manager.Create<RustWrapper>(PrefabRoot + "Container.Popup." + style + ".prefab");
		}

		public static RustWrapper Indent(string style = "Normal")
		{
			return Manager.Create<RustWrapper>(PrefabRoot + "Container.Indent." + style + ".prefab");
		}

		public static TabControl TabControl(string style = "Normal")
		{
			return Manager.Create<TabControl>(PrefabRoot + "TabControl." + style + ".prefab");
		}

		public static RustLayout Vertical(string style = "Normal")
		{
			return Manager.Create<RustLayout>(PrefabRoot + "Vertical." + style + ".prefab");
		}
	}

	public static class Form
	{
		public static RustWrapper Toolbar(string style = "Normal")
		{
			return Manager.Create<RustWrapper>(PrefabRoot + "Container.Toolbar." + style + ".prefab");
		}

		public static RustWrapper Popup(string style = "Normal")
		{
			return Manager.Create<RustWrapper>(PrefabRoot + "Container.Popup." + style + ".prefab");
		}

		public static RustWrapper Vertical(Phrase phrase, UIBehaviour control = null, string style = "Normal")
		{
			RustWrapper rustWrapper = Manager.Create<RustWrapper>(PrefabRoot + "Form.Vertical." + style + ".prefab");
			rustWrapper.Text.SetPhrase(phrase);
			if ((Object)(object)control != (Object)null)
			{
				rustWrapper.Add(control);
			}
			return rustWrapper;
		}

		public static RustWrapper Horizontal(Phrase phrase, UIBehaviour control = null, string style = "Normal")
		{
			RustWrapper rustWrapper = Manager.Create<RustWrapper>(PrefabRoot + "Form.Horizontal." + style + ".prefab");
			rustWrapper.Text.SetPhrase(phrase);
			if ((Object)(object)control != (Object)null)
			{
				rustWrapper.Add(control);
			}
			return rustWrapper;
		}
	}

	public static class Label
	{
		public static RustText Normal(Phrase text)
		{
			RustText rustText = Manager.Create<RustText>(PrefabRoot + "Label.Normal.prefab");
			rustText.SetPhrase(text);
			return rustText;
		}

		public static RustText Small(Phrase text)
		{
			RustText rustText = Manager.Create<RustText>(PrefabRoot + "Label.Small.prefab");
			rustText.SetPhrase(text);
			return rustText;
		}

		public static RustText Large(Phrase text)
		{
			RustText rustText = Manager.Create<RustText>(PrefabRoot + "Label.Large.prefab");
			rustText.SetPhrase(text);
			return rustText;
		}
	}

	public static string PrefabRoot = "Assets/Plugins/Rust.UI/Controls/";

	public static Phrase phrase_on = new Phrase("toggle.on", "On");

	public static Phrase phrase_off = new Phrase("toggle.off", "Off");

	public static Phrase phrase_enabled = new Phrase("toggle.enabled", "Enabled");

	public static Phrase phrase_disabled = new Phrase("toggle.disabled", "Disabled");

	public static LayoutElement Flex()
	{
		return Manager.Create<LayoutElement>(PrefabRoot + "Flex.prefab");
	}

	public static RustButton Button(Phrase label, Icons icon = Icons.InfoCircle, bool toggle = false, string style = "Normal", bool autoSize = false)
	{
		RustButton rustButton = Manager.Create<RustButton>(PrefabRoot + "RustButton." + style + ".prefab");
		rustButton.IsToggle = toggle;
		rustButton.AutoSize = autoSize;
		rustButton.Text.SetPhrase(label);
		rustButton.Icon.Icon = icon;
		return rustButton;
	}

	public static RustButton MenuOption(Phrase label, Icons icon = Icons.None, string style = "Normal")
	{
		RustButton rustButton = Manager.Create<RustButton>(PrefabRoot + "MenuOption." + style + ".prefab");
		if ((Object)(object)rustButton.Icon != (Object)null && rustButton.Icon.Icon != icon)
		{
			rustButton.Icon.Icon = icon;
		}
		if (rustButton.Icon.Icon == Icons.None)
		{
			rustButton.ApplyStyles();
		}
		rustButton.Text.SetPhrase(label);
		return rustButton;
	}

	public static Menu Menu(Option[] options, Option? selectedOption = null, bool AllowFiltering = false, string style = "Normal")
	{
		Menu menu = Manager.Create<Menu>(PrefabRoot + "Menu." + style + ".prefab");
		menu.AllowFiltering = AllowFiltering;
		menu.Options = options;
		if (selectedOption.HasValue)
		{
			menu.SelectedOption = selectedOption.Value;
		}
		return menu;
	}

	public static Video Video(string style = "Normal")
	{
		return Manager.Create<Video>(PrefabRoot + "Video." + style + ".prefab");
	}

	public static RustButton HeaderButton(Phrase label, Phrase subtitle, string style = "Header")
	{
		RustButton rustButton = Manager.Create<RustButton>(PrefabRoot + "RustButton." + style + ".prefab");
		rustButton.Text.SetPhrase(label);
		rustButton.SubText.SetPhrase(subtitle);
		return rustButton;
	}

	public static RustOption Option(Option[] enumOptions, string style = "Normal")
	{
		RustOption rustOption = Manager.Create<RustOption>(PrefabRoot + "RustOption." + style + ".prefab");
		rustOption.Options = enumOptions;
		rustOption.SetOptionDefault();
		return rustOption;
	}

	public static RustButtonGroup ButtonGroup(Option[] enumOptions, string style = "Normal")
	{
		RustButtonGroup rustButtonGroup = Manager.Create<RustButtonGroup>(PrefabRoot + "ButtonGroup." + style + ".prefab");
		rustButtonGroup.Options = enumOptions;
		rustButtonGroup.BuildContents();
		rustButtonGroup.SetOptionDefault();
		return rustButtonGroup;
	}

	public static Dropdown Dropdown(Option[] enumOptions, string style = "Normal")
	{
		Dropdown dropdown = Manager.Create<Dropdown>(PrefabRoot + "Dropdown." + style + ".prefab");
		dropdown.Options = enumOptions;
		dropdown.SetOptionDefault();
		return dropdown;
	}

	public static RustInput Input(Phrase placeholder = null, string style = "Normal")
	{
		RustInput rustInput = Manager.Create<RustInput>(PrefabRoot + "RustInput." + style + ".prefab");
		if (placeholder != null)
		{
			rustInput.Placeholder.SetPhrase(placeholder);
		}
		return rustInput;
	}

	public static RustIcon Icon(Icons icon = Icons.Radiation, string style = "Normal")
	{
		RustIcon rustIcon = Manager.Create<RustIcon>(PrefabRoot + "RustIcon." + style + ".prefab");
		rustIcon.Icon = icon;
		return rustIcon;
	}

	public static RustSlider Slider(float minValue, float maxValue, float currentValue, bool integer = false, string style = "Normal")
	{
		RustSlider rustSlider = Manager.Create<RustSlider>(PrefabRoot + "RustSlider." + style + ".prefab");
		rustSlider.Integer = integer;
		rustSlider.MinValue = minValue;
		rustSlider.MaxValue = maxValue;
		rustSlider.Value = currentValue;
		return rustSlider;
	}

	public static RustToggle Toggle(Phrase on, Phrase off, string style = "Normal")
	{
		RustToggle rustToggle = Manager.Create<RustToggle>(PrefabRoot + "RustToggle." + style + ".prefab");
		rustToggle.TextOn.SetPhrase(on);
		rustToggle.TextOff.SetPhrase(off);
		return rustToggle;
	}

	public static Blocker Blocker(string style = "Normal")
	{
		return Manager.Create<Blocker>(PrefabRoot + "Blocker." + style + ".prefab");
	}

	public static RustToggle ToggleOnOff(string style = "Normal")
	{
		return Toggle(phrase_on, phrase_off, style);
	}

	public static RustToggle ToggleEnabledDisabled(string style = "Normal")
	{
		return Toggle(phrase_enabled, phrase_disabled, style);
	}
}


using System;

public class ButtonGroupAttribute : Attribute
{
}


using System;

public class LabelAttribute : Attribute
{
	public Phrase Phrase;

	public LabelAttribute(string token, string english)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		Phrase = new Phrase(token, english);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json.Linq;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class Properties
{
	private object Parent;

	private RectTransform Canvas;

	public List<FieldInfo> Fields = new List<FieldInfo>();

	public bool IsDirty { get; set; }

	public event Action UpdateControlsFromValues;

	public Properties(object Parent, RectTransform Canvas)
	{
		this.Parent = Parent;
		this.Canvas = Canvas;
	}

	public void CreateControls()
	{
		FieldInfo[] fields = Parent.GetType().GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
		foreach (FieldInfo f in fields)
		{
			CreateControl(f);
		}
	}

	private void AddControl(RustControl ctrl, LabelAttribute label)
	{
		if (label != null)
		{
			RustWrapper rustWrapper = Make.Form.Horizontal(label.Phrase, (UIBehaviour)(object)ctrl);
			((Object)((Component)rustWrapper).gameObject).name = ((Object)((Component)ctrl).gameObject).name;
			((UIBehaviour)(object)rustWrapper).SetParent((Transform)(object)Canvas);
		}
		else
		{
			((UIBehaviour)(object)ctrl).SetParent((Transform)(object)Canvas);
		}
	}

	private bool CreateControl(FieldInfo f)
	{
		if (f.FieldType == typeof(float) || f.FieldType == typeof(int))
		{
			return CreateNumericControl(f);
		}
		if (f.FieldType == typeof(string))
		{
			return CreateStringControl(f);
		}
		if (f.FieldType == typeof(bool))
		{
			return CreateBooleanControl(f);
		}
		CreateReadOnlyControl(f);
		return false;
	}

	private bool CreateReadOnlyControl(FieldInfo f)
	{
		string name = f.Name;
		_ = f.FieldType == typeof(float);
		_ = f.FieldType == typeof(int);
		LabelAttribute customAttribute = f.GetCustomAttribute<LabelAttribute>();
		RustInput ctrl = Make.Input();
		((Object)((Component)ctrl).gameObject).name = name;
		ctrl.Text = $"{f.GetValue(Parent)}";
		AddControl(ctrl, customAttribute);
		UpdateControlsFromValues += delegate
		{
			ctrl.Text = $"{f.GetValue(Parent)}";
		};
		Fields.Add(f);
		return true;
	}

	private bool CreateStringControl(FieldInfo f)
	{
		string name = f.Name;
		LabelAttribute customAttribute = f.GetCustomAttribute<LabelAttribute>();
		ButtonGroupAttribute? customAttribute2 = f.GetCustomAttribute<ButtonGroupAttribute>();
		Option[] array = (from x in f.GetCustomAttributes<OptionAttribute>()
			select x.GetOption()).ToArray();
		if (customAttribute2 != null && array.Length != 0)
		{
			RustButtonGroup ctrl = Make.ButtonGroup(array, "FullWidth");
			((Object)((Component)ctrl).gameObject).name = name;
			((UnityEvent<Option>)ctrl.OnChanged).AddListener((UnityAction<Option>)delegate(Option x)
			{
				f.SetValue(Parent, x.Value);
				MarkDirty();
			});
			AddControl(ctrl, customAttribute);
			UpdateControlsFromValues += delegate
			{
				ctrl.SetOption((string)f.GetValue(Parent));
			};
			Fields.Add(f);
			return true;
		}
		return true;
	}

	private bool CreateBooleanControl(FieldInfo f)
	{
		string name = f.Name;
		LabelAttribute customAttribute = f.GetCustomAttribute<LabelAttribute>();
		RustToggle ctrl = Make.ToggleOnOff();
		((Object)((Component)ctrl).gameObject).name = name;
		((UnityEvent<bool>)ctrl.OnChanged).AddListener((UnityAction<bool>)delegate(bool x)
		{
			f.SetValue(Parent, x);
			MarkDirty();
		});
		ctrl.SetValue((bool)f.GetValue(Parent));
		AddControl(ctrl, customAttribute);
		UpdateControlsFromValues += delegate
		{
			ctrl.SetValue((bool)f.GetValue(Parent));
		};
		Fields.Add(f);
		return true;
	}

	private bool CreateNumericControl(FieldInfo f)
	{
		string name = f.Name;
		_ = f.FieldType == typeof(float);
		_ = f.FieldType == typeof(int);
		LabelAttribute customAttribute = f.GetCustomAttribute<LabelAttribute>();
		RangeAttribute customAttribute2 = ((MemberInfo)f).GetCustomAttribute<RangeAttribute>();
		if (customAttribute2 != null)
		{
			RustSlider ctrl = Make.Slider(customAttribute2.min, customAttribute2.max, 0.5f);
			((Object)((Component)ctrl).gameObject).name = name;
			((UnityEvent<float>)ctrl.OnChanged).AddListener((UnityAction<float>)delegate(float x)
			{
				f.SetValue(Parent, x);
				MarkDirty();
			});
			ctrl.Value = (float)f.GetValue(Parent);
			AddControl(ctrl, customAttribute);
			UpdateControlsFromValues += delegate
			{
				ctrl.Value = (float)f.GetValue(Parent);
			};
			Fields.Add(f);
			return true;
		}
		return CreateReadOnlyControl(f);
	}

	public void SyncControls()
	{
		this.UpdateControlsFromValues?.Invoke();
	}

	public Dictionary<string, object> GetValues()
	{
		Dictionary<string, object> dictionary = new Dictionary<string, object>();
		foreach (FieldInfo field in Fields)
		{
			dictionary.Add(field.Name, field.GetValue(Parent));
		}
		return dictionary;
	}

	public void SetValues(Dictionary<string, object> d)
	{
		foreach (FieldInfo field in Fields)
		{
			if (d.TryGetValue(field.Name, out var value))
			{
				field.SetValue(Parent, value);
			}
		}
	}

	public void SetValues(Dictionary<string, object> a, Dictionary<string, object> b, float delta)
	{
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		foreach (FieldInfo field in Fields)
		{
			if (!a.TryGetValue(field.Name, out var value) || !b.TryGetValue(field.Name, out var value2))
			{
				continue;
			}
			if (field.FieldType == typeof(float))
			{
				float num = Mathf.Lerp((float)value, (float)value2, delta);
				field.SetValue(Parent, num);
			}
			else if (field.FieldType == typeof(Vector3))
			{
				if (field.Name.StartsWith("Rot"))
				{
					Quaternion val = Quaternion.Lerp(Quaternion.Euler((Vector3)value), Quaternion.Euler((Vector3)value2), delta);
					field.SetValue(Parent, ((Quaternion)(ref val)).eulerAngles);
				}
				else
				{
					Vector3 val2 = Vector3.Lerp((Vector3)value, (Vector3)value2, delta);
					field.SetValue(Parent, val2);
				}
			}
			else
			{
				field.SetValue(Parent, value);
			}
		}
	}

	private void MarkDirty()
	{
		IsDirty = true;
	}

	public void Load(JProperty entry)
	{
		JToken value = entry.Value;
		JObject val = (JObject)(object)((value is JObject) ? value : null);
		JToken val2 = default(JToken);
		foreach (FieldInfo field in Fields)
		{
			if (val.TryGetValue(field.Name, ref val2))
			{
				field.SetValue(Parent, val2.ToObject(field.FieldType));
			}
		}
	}
}


using System;
using Rust.UI;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/UI/StyleAsset")]
public class StyleAsset : ScriptableObject
{
	[Serializable]
	public class Group
	{
		public Color Bg = Color.black;

		public Color Fg = Color.white;

		public Color Icon = Color.white;
	}

	[Serializable]
	public class OverrideGroup : Group
	{
		public bool OverrideBg = true;

		public bool OverrideFg = true;

		public bool OverrideIcon = true;
	}

	public Group Normal;

	public OverrideGroup Hovered;

	public OverrideGroup Pressed;

	public OverrideGroup Disabled;
}


using Rust.UI;
using UnityEngine;

public struct StyleColorSet
{
	public Color Bg;

	public Color Fg;

	public Color Icon;

	public StyleColorSet(StyleAsset.Group baseColors)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Bg = baseColors.Bg;
		Fg = baseColors.Fg;
		Icon = baseColors.Icon;
	}

	public void Apply(StyleAsset.OverrideGroup overrideColors)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (overrideColors.OverrideBg)
		{
			Bg = overrideColors.Bg;
		}
		if (overrideColors.OverrideFg)
		{
			Fg = overrideColors.Fg;
		}
		if (overrideColors.OverrideIcon)
		{
			Icon = overrideColors.Icon;
		}
	}
}


using Rust.UI;

public class SuppressMenu : ListComponent<SuppressMenu>
{
	public static bool Any => ListComponent<SuppressMenu>.InstanceList.Count > 0;
}


using System;
using System.Collections;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class FileDialog : MonoBehaviour
{
	public enum FileDialogMode
	{
		Open,
		Save
	}

	[HideInInspector]
	public string result;

	[HideInInspector]
	private FileDialogMode mode;

	[HideInInspector]
	public bool finished;

	[Header("References")]
	public Image windowIcon;

	public Text windowName;

	public InputField currentPath;

	public InputField fileName;

	public Button up;

	public Button commit;

	public Button cancel;

	public GameObject filesScrollRectContent;

	public GameObject drivesScrollRectContent;

	[Header("Lists Prefabs")]
	public GameObject filesScrollRectElement;

	public GameObject drivesScrollRectElement;

	[Header("Lists Icons")]
	public Sprite folderIcon;

	public Sprite fileIcon;

	private string workingPath;

	private string workingFile;

	private string[] allowedExtensions;

	private long maxSize = -1L;

	private bool saveLastPath = true;

	public IEnumerator Open(string path = null, string allowedExtensions = null, string windowName = "OPEN FILE", Sprite windowIcon = null, long maxSize = -1L, bool saveLastPath = true)
	{
		mode = FileDialogMode.Open;
		((Component)commit).GetComponentInChildren<Text>().text = "OPEN";
		fileName.text = "";
		workingPath = "";
		workingFile = "";
		result = null;
		finished = false;
		this.maxSize = maxSize;
		this.saveLastPath = saveLastPath;
		if (!string.IsNullOrEmpty(allowedExtensions))
		{
			allowedExtensions = allowedExtensions.ToLower();
			this.allowedExtensions = allowedExtensions.Split('|');
		}
		if (string.IsNullOrEmpty(path))
		{
			path = ((!saveLastPath) ? (Application.dataPath + "/../") : (string.IsNullOrEmpty(PlayerPrefs.GetString("OxOD.lastPath", (string)null)) ? (Application.dataPath + "/../") : PlayerPrefs.GetString("OxOD.lastPath", (string)null)));
		}
		this.windowName.text = windowName;
		if (Object.op_Implicit((Object)(object)windowIcon))
		{
			this.windowIcon.sprite = windowIcon;
		}
		GoTo(path);
		((Component)this).gameObject.SetActive(true);
		while (!finished)
		{
			yield return (object)new WaitForSeconds(0.1f);
		}
	}

	public IEnumerator Save(string path = null, string allowedExtensions = null, string windowName = "SAVE FILE", Sprite windowIcon = null, bool saveLastPath = true, string defaultFileName = null)
	{
		mode = FileDialogMode.Save;
		((Component)commit).GetComponentInChildren<Text>().text = "SAVE";
		fileName.text = "";
		workingPath = "";
		workingFile = "";
		result = null;
		finished = false;
		maxSize = -1L;
		this.saveLastPath = saveLastPath;
		if (!string.IsNullOrEmpty(allowedExtensions))
		{
			allowedExtensions = allowedExtensions.ToLower();
			this.allowedExtensions = allowedExtensions.Split('|');
		}
		else
		{
			this.allowedExtensions = null;
		}
		if (string.IsNullOrEmpty(path))
		{
			path = ((!saveLastPath) ? (Application.dataPath + "/../") : (string.IsNullOrEmpty(PlayerPrefs.GetString("OxOD.lastPath", (string)null)) ? (Application.dataPath + "/../") : PlayerPrefs.GetString("OxOD.lastPath", (string)null)));
		}
		this.windowName.text = windowName;
		if (Object.op_Implicit((Object)(object)windowIcon))
		{
			this.windowIcon.sprite = windowIcon;
		}
		GoTo(path);
		((Component)this).gameObject.SetActive(true);
		if (!string.IsNullOrEmpty(defaultFileName))
		{
			OnTypedEnd(defaultFileName);
		}
		while (!finished)
		{
			yield return (object)new WaitForSeconds(0.1f);
		}
	}

	public async Task<string> SaveAsync(string path = null, string allowedExtensions = null, string windowName = "SAVE FILE", Sprite windowIcon = null, bool saveLastPath = true)
	{
		mode = FileDialogMode.Save;
		((Component)commit).GetComponentInChildren<Text>().text = "SAVE";
		fileName.text = "";
		workingPath = "";
		workingFile = "";
		result = null;
		finished = false;
		maxSize = -1L;
		this.saveLastPath = saveLastPath;
		if (!string.IsNullOrEmpty(allowedExtensions))
		{
			allowedExtensions = allowedExtensions.ToLower();
			this.allowedExtensions = allowedExtensions.Split('|');
		}
		else
		{
			this.allowedExtensions = null;
		}
		if (string.IsNullOrEmpty(path))
		{
			path = ((!saveLastPath) ? (Application.dataPath + "/../") : (string.IsNullOrEmpty(PlayerPrefs.GetString("OxOD.lastPath", (string)null)) ? (Application.dataPath + "/../") : PlayerPrefs.GetString("OxOD.lastPath", (string)null)));
		}
		this.windowName.text = windowName;
		if (Object.op_Implicit((Object)(object)windowIcon))
		{
			this.windowIcon.sprite = windowIcon;
		}
		GoTo(path);
		((Component)this).gameObject.SetActive(true);
		while (!finished)
		{
			await Task.Delay(100);
		}
		return result;
	}

	private void Hide()
	{
		((Component)this).gameObject.SetActive(false);
	}

	public void GoUp()
	{
		OpenDir(workingPath + "/../");
	}

	public void GoTo(string newPath)
	{
		if (new DirectoryInfo(newPath).Exists)
		{
			OpenDir(newPath + "/");
		}
		else if (mode == FileDialogMode.Open)
		{
			if (new FileInfo(newPath).Exists)
			{
				OpenDir(new FileInfo(newPath).Directory.FullName + "/");
				SelectFile(newPath);
			}
			else
			{
				OpenDir(Application.dataPath + "/../");
			}
		}
		else if (new DirectoryInfo(new FileInfo(newPath).Directory.FullName + "/").Exists)
		{
			OpenDir(new FileInfo(newPath).Directory.FullName + "/");
			SelectFile(newPath);
		}
		else
		{
			OpenDir(Application.dataPath + "/../");
		}
	}

	public void SelectFile(string file)
	{
		if (mode == FileDialogMode.Open)
		{
			workingFile = Path.GetFullPath(file);
		}
		else
		{
			workingFile = new FileInfo(Path.GetFullPath(file)).Name;
		}
		UpdateFileInfo();
	}

	public void OnCommitClick()
	{
		if (mode == FileDialogMode.Open)
		{
			result = Path.GetFullPath(workingFile);
		}
		else
		{
			result = Path.GetFullPath(workingPath + "/" + workingFile);
		}
		finished = true;
		if (saveLastPath)
		{
			PlayerPrefs.SetString("OxOD.lastPath", workingPath);
		}
		Hide();
	}

	public void OnCancelClick()
	{
		result = null;
		finished = true;
		Hide();
	}

	public void ClearSelection()
	{
		if (mode == FileDialogMode.Open)
		{
			workingFile = "";
			UpdateFileInfo();
		}
	}

	public void OnTypedFilename(string newName)
	{
		if (mode == FileDialogMode.Open)
		{
			workingFile = workingPath + "/" + newName;
		}
		else
		{
			workingFile = newName;
		}
		UpdateFileInfo();
	}

	public void OnTypedEnd(string newName)
	{
		if (string.IsNullOrEmpty(newName))
		{
			return;
		}
		if (mode == FileDialogMode.Save)
		{
			if (allowedExtensions != null)
			{
				if (allowedExtensions.Contains(new FileInfo(newName).Extension.ToLower()))
				{
					workingFile = newName;
				}
				else
				{
					workingFile = newName + allowedExtensions[0];
				}
			}
			else
			{
				workingFile = newName;
			}
		}
		UpdateFileInfo();
	}

	public void UpdateFileInfo()
	{
		if (mode == FileDialogMode.Open)
		{
			try
			{
				fileName.text = new FileInfo(workingFile).Name;
				((Selectable)commit).interactable = File.Exists(workingFile);
				return;
			}
			catch (Exception)
			{
				fileName.text = "";
				((Selectable)commit).interactable = false;
				return;
			}
		}
		if (workingFile.Length > 0)
		{
			fileName.text = new FileInfo(workingFile).Name;
		}
		((Selectable)commit).interactable = workingFile.Length > 0;
	}

	public void OpenDir(string path)
	{
		ClearSelection();
		workingPath = Path.GetFullPath(path);
		UpdateElements();
		UpdateDrivesList();
		UpdateFilesList();
	}

	private void UpdateElements()
	{
		currentPath.text = workingPath;
	}

	private void UpdateDrivesList()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = drivesScrollRectContent;
		for (int i = 0; i < val.transform.childCount; i++)
		{
			Object.Destroy((Object)(object)((Component)val.transform.GetChild(i)).gameObject);
		}
		string[] logicalDrives = Directory.GetLogicalDrives();
		for (int j = 0; j < logicalDrives.Length; j++)
		{
			GameObject obj = Object.Instantiate<GameObject>(drivesScrollRectElement, Vector3.zero, Quaternion.identity);
			obj.transform.SetParent(val.transform, true);
			obj.transform.localScale = new Vector3(1f, 1f, 1f);
			FileListElement component = obj.GetComponent<FileListElement>();
			component.instance = this;
			component.data = logicalDrives[j];
			component.elementName.text = logicalDrives[j];
			component.isFile = false;
		}
	}

	private string GetFileSizeText(long size)
	{
		string text = "#.##";
		if ((float)size / 1024f < 1f)
		{
			return "1 Kb";
		}
		if ((float)size / 1024f < 1024f)
		{
			return ((float)size / 1024f).ToString(text) + " Kb";
		}
		if ((float)size / 1024f / 1024f < 1024f)
		{
			return ((float)size / 1024f / 1024f).ToString(text) + " Mb";
		}
		return ((float)size / 1024f / 1024f / 1024f).ToString(text) + " Gb";
	}

	private void UpdateFilesList()
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_041d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = filesScrollRectContent;
		for (int i = 0; i < val.transform.childCount; i++)
		{
			Object.Destroy((Object)(object)((Component)val.transform.GetChild(i)).gameObject);
		}
		DirectoryInfo directoryInfo = new DirectoryInfo(workingPath);
		try
		{
			DirectoryInfo[] directories = directoryInfo.GetDirectories();
			for (int j = 0; j < directories.Length; j++)
			{
				if (directories[j].Name[0] != '@' && directories[j].Name[0] != '.' && (directories[j].Attributes & FileAttributes.Hidden) != FileAttributes.Hidden)
				{
					GameObject obj = Object.Instantiate<GameObject>(filesScrollRectElement, Vector3.zero, Quaternion.identity);
					obj.transform.SetParent(val.transform, true);
					obj.transform.localScale = new Vector3(1f, 1f, 1f);
					FileListElement component = obj.GetComponent<FileListElement>();
					component.instance = this;
					component.data = directories[j].FullName + "/";
					component.elementName.text = directories[j].Name;
					component.size.text = "";
					component.icon.sprite = folderIcon;
					component.isFile = false;
				}
			}
			if (allowedExtensions != null)
			{
				FileInfo[] array = (from f in directoryInfo.GetFiles()
					where allowedExtensions.Contains(f.Extension.ToLower())
					select f).ToArray();
				for (int k = 0; k < array.Length; k++)
				{
					if (maxSize > 0)
					{
						if (array[k].Length < maxSize)
						{
							GameObject obj2 = Object.Instantiate<GameObject>(filesScrollRectElement, Vector3.zero, Quaternion.identity);
							obj2.transform.SetParent(val.transform, true);
							obj2.transform.localScale = new Vector3(1f, 1f, 1f);
							FileListElement component2 = obj2.GetComponent<FileListElement>();
							component2.instance = this;
							component2.data = array[k].FullName;
							component2.size.text = GetFileSizeText(array[k].Length);
							component2.elementName.text = array[k].Name;
							component2.icon.sprite = fileIcon;
							component2.isFile = true;
						}
					}
					else
					{
						GameObject obj3 = Object.Instantiate<GameObject>(filesScrollRectElement, Vector3.zero, Quaternion.identity);
						obj3.transform.SetParent(val.transform, true);
						obj3.transform.localScale = new Vector3(1f, 1f, 1f);
						FileListElement component3 = obj3.GetComponent<FileListElement>();
						component3.instance = this;
						component3.data = array[k].FullName;
						component3.size.text = GetFileSizeText(array[k].Length);
						component3.elementName.text = array[k].Name;
						component3.icon.sprite = fileIcon;
						component3.isFile = true;
					}
				}
				return;
			}
			FileInfo[] files = directoryInfo.GetFiles();
			for (int l = 0; l < files.Length; l++)
			{
				if (maxSize > 0)
				{
					if (files[l].Length < maxSize)
					{
						GameObject obj4 = Object.Instantiate<GameObject>(filesScrollRectElement, Vector3.zero, Quaternion.identity);
						obj4.transform.SetParent(val.transform, true);
						obj4.transform.localScale = new Vector3(1f, 1f, 1f);
						FileListElement component4 = obj4.GetComponent<FileListElement>();
						component4.instance = this;
						component4.data = files[l].FullName;
						component4.size.text = GetFileSizeText(files[l].Length);
						component4.elementName.text = files[l].Name;
						component4.icon.sprite = fileIcon;
						component4.isFile = true;
					}
				}
				else
				{
					GameObject obj5 = Object.Instantiate<GameObject>(filesScrollRectElement, Vector3.zero, Quaternion.identity);
					obj5.transform.SetParent(val.transform, true);
					obj5.transform.localScale = new Vector3(1f, 1f, 1f);
					FileListElement component5 = obj5.GetComponent<FileListElement>();
					component5.instance = this;
					component5.data = files[l].FullName;
					component5.size.text = GetFileSizeText(files[l].Length);
					component5.elementName.text = files[l].Name;
					component5.icon.sprite = fileIcon;
					component5.isFile = true;
				}
			}
		}
		catch (Exception)
		{
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class FileListElement : MonoBehaviour
{
	public Image icon;

	public Text elementName;

	public Text size;

	public FileDialog instance;

	public bool isFile;

	public string data;

	public void OnClick()
	{
		if (!isFile)
		{
			instance.OpenDir(data);
		}
		else
		{
			instance.SelectFile(data);
		}
	}
}


using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
internal class ToggleGameObject : MonoBehaviour
{
	public GameObject Target;

	private Toggle component;

	public void OnEnable()
	{
		component = ((Component)this).GetComponent<Toggle>();
		((UnityEvent<bool>)(object)component.onValueChanged).AddListener((UnityAction<bool>)OnToggled);
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			((UnityEvent<bool>)(object)component.onValueChanged).RemoveListener((UnityAction<bool>)OnToggled);
		}
	}

	public void Update()
	{
		component.isOn = Target.activeSelf;
	}

	public void OnToggled(bool value)
	{
		Target.SetActive(value);
	}
}


using System.Collections.Generic;
using Rust.UI.Renderer;
using UnityEngine;
using UnityEngine.UI;

public class TickRenderer : MaskableGraphic
{
	public struct Tick
	{
		public float Pos;

		public Color Color;

		public float Height;
	}

	public List<Tick> Ticks = new List<Tick>();

	private static UIVertex[] quad = (UIVertex[])(object)new UIVertex[4];

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		vh.Clear();
		Transform transform = ((Component)this).transform;
		float height = ((RectTransform)(object)((transform is RectTransform) ? transform : null)).GetHeight();
		foreach (Tick tick in Ticks)
		{
			UIVertex val = default(UIVertex);
			val.color = Color32.op_Implicit(tick.Color * ((Graphic)this).color);
			val.position = new Vector3(tick.Pos, 0f);
			UIVertex val2 = val;
			quad[0] = val2;
			val2.position = new Vector3(tick.Pos + 1f, 0f);
			quad[1] = val2;
			val2.position = new Vector3(tick.Pos + 1f, height * tick.Height);
			quad[2] = val2;
			val2.position = new Vector3(tick.Pos, height * tick.Height);
			quad[3] = val2;
			vh.AddUIVertexQuad(quad);
		}
	}
}


using System.Collections.Generic;
using System.Linq;
using Network;
using Rust.UI.Debugging;
using UnityEngine;

public class NetGraph : SingletonComponent<NetGraph>
{
	public CanvasGroup group;

	public GameObject rootPanel;

	private NetGraphRow[] rows;

	public bool Enabled
	{
		set
		{
			group.alpha = (value ? 1 : 0);
			rootPanel.SetActive(value);
		}
	}

	public void Start()
	{
		rows = ((Component)this).GetComponentsInChildren<NetGraphRow>(true);
	}

	public void UpdateFrom(Stats incomingStats)
	{
		for (int i = 0; i < rows.Length; i++)
		{
			rows[i].Hide();
		}
		int num = 0;
		foreach (KeyValuePair<string, Node> item in incomingStats.Previous.Children.OrderByDescending((KeyValuePair<string, Node> y) => y.Value.Bytes))
		{
			if (num >= rows.Length)
			{
				break;
			}
			rows[num].UpdateFrom(item);
			num++;
		}
	}
}


using System.Collections.Generic;
using Facepunch.Extend;
using Network;
using UnityEngine;
using UnityEngine.UI;

public class NetGraphItem : MonoBehaviour
{
	public CanvasGroup group;

	public LayoutElement element;

	public Text countTotal;

	public Text label;

	public Text bytes;

	internal void Hide()
	{
		group.alpha = 0f;
		element.ignoreLayout = true;
	}

	internal void UpdateFrom(KeyValuePair<string, Node> node)
	{
		element.ignoreLayout = false;
		group.alpha = 1f;
		element.flexibleWidth = (float)node.Value.Bytes / 2048f;
		label.text = node.Key;
		bytes.text = NumberExtensions.FormatBytes<long>(node.Value.Bytes, false);
		countTotal.text = node.Value.Count.ToString("N0");
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Network;
using Rust.UI.Debugging;
using UnityEngine;
using UnityEngine.UI;

public class NetGraphRow : MonoBehaviour
{
	public CanvasGroup group;

	public Text countTotal;

	public Text countUnique;

	public Text label;

	public Text bytes;

	public GameObject RowContainer;

	public NetGraphItem[] Items;

	public GameObject RowSpacer;

	private void Awake()
	{
		Items = ((Component)this).GetComponentsInChildren<NetGraphItem>();
	}

	internal void Hide()
	{
		group.alpha = 0f;
	}

	internal void UpdateFrom(KeyValuePair<string, Node> node)
	{
		group.alpha = 1f;
		label.text = node.Key;
		bytes.text = NumberExtensions.FormatBytes<long>(node.Value.Bytes, false);
		countTotal.text = node.Value.Count.ToString("N0");
		countUnique.text = ((node.Value.Children == null) ? "0" : node.Value.Children.Count.ToString("N0"));
		NetGraphItem[] items = Items;
		for (int i = 0; i < items.Length; i++)
		{
			items[i].Hide();
		}
		if (node.Value.Children == null)
		{
			return;
		}
		int num = 0;
		foreach (KeyValuePair<string, Node> item in node.Value.Children.OrderByDescending((KeyValuePair<string, Node> y) => y.Value.Bytes))
		{
			if (num >= Items.Length)
			{
				break;
			}
			Items[num].UpdateFrom(item);
			num++;
		}
	}
}


private struct MonoScriptData
{
	public byte[] FilePathsData;

	public byte[] TypesData;

	public int TotalTypes;

	public int TotalFiles;

	public bool IsEditorOnly;
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<Option>
{
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<Option>
{
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<Option>
{
}


using System;

[Flags]
public enum State
{
	Normal = 1,
	Hovered = 2,
	Pressed = 4,
	Active = 8,
	Disabled = 0x10
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<string>
{
}


public enum LayoutMode
{
	Top,
	Left,
	Right,
	Bottom
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<Option>
{
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<float>
{
}


using System;
using UnityEngine.Events;

[Serializable]
public class ChangedEvent : UnityEvent<bool>
{
}


using System;
using UnityEngine.Events;

[Serializable]
public class ScrubEvent : UnityEvent<float>
{
}


public static class Container
{
	public static RustWrapper Toolbar(string style = "Normal")
	{
		return Manager.Create<RustWrapper>(PrefabRoot + "Container.Toolbar." + style + ".prefab");
	}

	public static RustWrapper Popup(string style = "Normal")
	{
		return Manager.Create<RustWrapper>(PrefabRoot + "Container.Popup." + style + ".prefab");
	}

	public static RustWrapper Indent(string style = "Normal")
	{
		return Manager.Create<RustWrapper>(PrefabRoot + "Container.Indent." + style + ".prefab");
	}

	public static TabControl TabControl(string style = "Normal")
	{
		return Manager.Create<TabControl>(PrefabRoot + "TabControl." + style + ".prefab");
	}

	public static RustLayout Vertical(string style = "Normal")
	{
		return Manager.Create<RustLayout>(PrefabRoot + "Vertical." + style + ".prefab");
	}
}


using UnityEngine;
using UnityEngine.EventSystems;

public static class Form
{
	public static RustWrapper Toolbar(string style = "Normal")
	{
		return Manager.Create<RustWrapper>(PrefabRoot + "Container.Toolbar." + style + ".prefab");
	}

	public static RustWrapper Popup(string style = "Normal")
	{
		return Manager.Create<RustWrapper>(PrefabRoot + "Container.Popup." + style + ".prefab");
	}

	public static RustWrapper Vertical(Phrase phrase, UIBehaviour control = null, string style = "Normal")
	{
		RustWrapper rustWrapper = Manager.Create<RustWrapper>(PrefabRoot + "Form.Vertical." + style + ".prefab");
		rustWrapper.Text.SetPhrase(phrase);
		if ((Object)(object)control != (Object)null)
		{
			rustWrapper.Add(control);
		}
		return rustWrapper;
	}

	public static RustWrapper Horizontal(Phrase phrase, UIBehaviour control = null, string style = "Normal")
	{
		RustWrapper rustWrapper = Manager.Create<RustWrapper>(PrefabRoot + "Form.Horizontal." + style + ".prefab");
		rustWrapper.Text.SetPhrase(phrase);
		if ((Object)(object)control != (Object)null)
		{
			rustWrapper.Add(control);
		}
		return rustWrapper;
	}
}


public static class Label
{
	public static RustText Normal(Phrase text)
	{
		RustText rustText = Manager.Create<RustText>(PrefabRoot + "Label.Normal.prefab");
		rustText.SetPhrase(text);
		return rustText;
	}

	public static RustText Small(Phrase text)
	{
		RustText rustText = Manager.Create<RustText>(PrefabRoot + "Label.Small.prefab");
		rustText.SetPhrase(text);
		return rustText;
	}

	public static RustText Large(Phrase text)
	{
		RustText rustText = Manager.Create<RustText>(PrefabRoot + "Label.Large.prefab");
		rustText.SetPhrase(text);
		return rustText;
	}
}


using System;
using UnityEngine;

[Serializable]
public class Group
{
	public Color Bg = Color.black;

	public Color Fg = Color.white;

	public Color Icon = Color.white;
}


using System;

[Serializable]
public class OverrideGroup : Group
{
	public bool OverrideBg = true;

	public bool OverrideFg = true;

	public bool OverrideIcon = true;
}


public enum FileDialogMode
{
	Open,
	Save
}


using UnityEngine;

public struct Tick
{
	public float Pos;

	public Color Color;

	public float Height;
}


